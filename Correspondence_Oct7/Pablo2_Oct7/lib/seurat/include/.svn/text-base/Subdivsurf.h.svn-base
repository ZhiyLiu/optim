/****************************************************************************/
/*																			*/
/*  	File	:  Subdivsurf												*/
/*																			*/
/*	Description:  class declaration for Subdivsurf, a standalone class for	*/
/*		creating and OpenGL rendering of subdivision surfaces as wireframes	*/
/*		given an initializing Mfig model. (single figure)					*/
/*																			*/
/*	Project :  Seurat														*/
/*																			*/
/*	Author  :  A. Thall														*/
/*																			*/
/*	Date	:  8. April 2000												*/
/*																			*/
/*	Modifications:															*/
/*		4. May 2000 -- Added function to return pointer to diatomgrid		*/
/*		27. May -- Added subdiv levels 5-7, added normlist, radiuslist,		*/
/*			and parent-atoms struct to subdivObjlist.						*/
/*		28. May -- added create_{pointlist, normlist, radiilist}			*/
/*			to support Pointlist_server class.								*/
/*			Added create_Parentsets() routine to support Pointlist_server	*/
/*		30. May -- added support for ->parentlist field of new diatomgrid	*/
/*		31. May -- added routines to output pointregions for selected		*/
/*			diatoms from generating Diatomgraph (NOT current one!)			*/
/*		10. June -- class encapsulated subdivnode so can use operator=()	*/
/*			and setvals() to clean up code a bit.							*/
/*		4. Jul -- added GLrenderv1v2bTOL() to render boundary involute		*/
/*			vectors with their cyan-labeled tolerance regions				*/
/*		6. Dec -- added stdio.h since removed from standard includes		*/
/*			Fixed operator= to return reference to self						*/
/*			Also modified destructor---new Diatomgrid class has its own,	*/
/*			  so simpler to delete these objects.							*/
/*		2. May 01 -- added Subdiv_tileinfo() to generate Bpointlist for		*/
/*			external processing.  (u, v, t) are dummy values---only pnt[],	*/
/*			norm[], and rad are set.										*/
/*			Added Subdiv_boundaryinfo() to give just the boundary vertices,	*/
/*          rather than the tile list.										*/
/*		3. May 01 -- eliminated deletion of fig_grid from destructor		*/
/*		4. May 01 -- added get_tileneighbors(), using typedefed int[8]		*/
/*          Tileneighbors as defined below.									*/
/*		22. May 01 -- set up routines to give correct (u, v, t) values		*/
/*			for subdivision mesh.											*/
/*			#define NORMALIZE_UVT in header file gives all coords in [0, 1].*/
/*			else (u, v, t) in ([0, numcols - 1], [0, numrows - 1], [-1, 1].	*/
/*		5. June 01 -- simplified mesh array structure for class.  Began		*/
/*			mods to more general subdivision grid, with limit points and	*/
/*			limit-point normals for output modeling and display purposes.	*/
/*		7. June 01-	Eliminated 	int create_pointlist(double **veclistptr)	*/
/*						int create_normlist(double **veclistptr)			*/
/*						int create_radiilist(double **radiiptr) which were	*/
/*						for old PointlistServer and not used anymore.		*/
/*				Added compute_limitpoint() and create_limit_mesh()			*/
/*				Added MAKE_LIMITSURFACE flag, temp for now					*/
/*		24. Jun -- added inverse_limit_mesh() and compute_inverse_point()	*/
/*          to produce a perturbed sub[0] mesh according to an approximation*/
/*          of the desired limit positions.									*/
/*		9. Aug -- added compute_inverselimitpointLEVEL2() to produce a		*/
/*			second level of iteration to approach an interpolating surface.	*/
/*		13. Aug -- modified subdiv_tileinfo to give num_{u, v, t} rows to	*/
/*          to calling function for indexing purposes.  All of these functs */
/*          need to be sensibly folded back into a real subdivision boundary*/
/*          class.  Damnit, if I ever had fucking time to write code.		*/
/*		22. Aug -- added subdivgrid *limitsubmesh to keep pointer to alloc.	*/
/*			limitsurface, to fix bug in Subdivsurf::mod_subdiv().  Added	*/
/*			delete of same to destructor.									*/
/*		23. Aug -- fixed bug in destructor of subdivrenderobjs				*/
/*		12. Nov -- added get_vertexneighbors() for output of local			*/
/*			8-neighborhoods (6-neighborhoods) to pointlist_server2.			*/
/*		23. Jan 02 -- added Subdiv_tileindices(), returns tilelist			*/
/*			generated by Subdiv_tileinfo() as quads of indices into			*/
/*			list returned by Subdiv_boundaryinfo(), not explicit Bpoints	*/
/*		18. June 02 -- added true_nodeloc/true_nodenorm to subgridnode		*/
/*			added create_normalinterpolating_mesh() to create a normal-		*/
/*			interpolating level-2 mesh and substitute it for the current.	*/
/*		21. June 02 -- rewrote average() to use vneighbor information, so	*/
/*			eliminated 8- 6- and 4- neighborhood special case functions.	*/
/*		22. June -- rewrote to eliminate create_Parent{}() functions and	*/
/*			all supporting and dependent code for them.						*/
/*		23. June -- moved constructors and destructors to .cpp file; they	*/
/*			contain loops, and would not be in-lined in any case.			*/
/*		24. June -- removed .plist Parentsets and all subdivision of them.	*/
/****************************************************************************/

// Comment the following #define out for non-normalized object coordinates
//    NOTE:  normalized object coordinates will *NOT* work with current
//          (u,v,t)-to-Bposition code in Pointlist_server2
//#define NORMALIZE_UVT

#include <assert.h>

#define MAX_TILE_NEIGHBORS	32

#define MIN_SUBDIV_LEVEL_TO_INTERPOLATE_BP	3

typedef enum { WIREFRAME, FILLEDPOLY, VPOINTS, NO_RENDER } RenderStyle;

// integer array for returning neighbor tiles for indexed elements of tileset
//    (must be some simpler way, but couldn't figure how to typedef an array.)
// (could have #defined it, I guess)
class Tileneighbors
{
	int neighbors[2*MAX_TILE_NEIGHBORS+1];
public:
	int& operator[](int val) {
		assert( val < sizeof(neighbors)/sizeof(int) && val >= 0);
		return neighbors[val];
	}
	void load(int tdex0, int tdex1, int tdex2, int tdex3, 
			  int tdex4, int tdex5, int tdex6, int tdex7);
};

//  to store all "neighboring" vertices 
//	  used in the area calculation in Mask::Mask(...)
class NeighborVertices
{
	Bpoint nVerts[2*MAX_TILE_NEIGHBORS];
public:
	int nNumber;
	Bpoint& operator[](int val) {
		assert( nNumber < MAX_TILE_NEIGHBORS );
		assert( val < 2*nNumber && val >= 0 );
		return nVerts[val];
	}
};


class Medcoord
{
public:
	double u;
	double v;
	double t;

	enum medcoord_t { SlabMedCoord, TubeMedCoord };

	// constructor
	Medcoord() { ; }
	Medcoord(double in_u, double in_v, double in_t) { u = in_u; v = in_v; t = in_t; }

	/**
	 * conversion from a bpoint to a medcoord.
	 */
	Medcoord( const Bpoint& bp ) {
		u	= bp.u;
		v	= bp.v;
		t	= bp.t;
	}
	Medcoord& operator = (const Medcoord& in) {
		u	= in.u;
		v	= in.v;
		t	= in.t;
		return *this;
	}

	void setvals(double in_u, double in_v, double in_t) { u = in_u; v = in_v; t = in_t; }

	//
	// FIXME: Deprecated functions - use corresponding ones from Mesh
	//

	Medcoord operator+(const Medcoord& mcoords) { 
		return Medcoord(u + mcoords.u, v + mcoords.v,  t + mcoords.t);
	}

	Medcoord& operator+=(const Medcoord& mcoords) {
		u += mcoords.u; v += mcoords.v; t += mcoords.t;
		return (*this);
	}

	Medcoord operator/(const double scaler) {
		return Medcoord(u / scaler, v / scaler, t / scaler);
	}

	Medcoord& operator/=(const double scaler) {
		u /= scaler; v /= scaler; t /= scaler; return (*this);
	}

	/**
	 * Takes n medial coordinates and computes their average.
	 * The result is saved in the current coordinate only if it
	 * was successful.
	 * @param	n	number of medial coordinates.
	 * @param	uvt	an array of medial coordinates.
	 * @param	medcoord_t	Whether slab or tube medial coordinate.
	 * @return	Whether successful or not.
	 *
	 * Ideally this function should be in Mesh or M3DFigure.
	 */
	bool average( int n, const Medcoord* uvt, medcoord_t type );

	/**
	 * Returns distance between this and another medial coord
	 * in the parameter space weighting different directions equally.
	 * @param	uvt		The other medial coordinate
	 * @param	type	Whether slab or tube medial coordinate.
	 * @return	The distance between the two coordinates.
	 */
	double distance( const Medcoord& uvt, medcoord_t type ) const;
};


class subgridnode
{
public:
    DbVector3 nodeloc; 		// node location
	DbVector3 nodenorm;
	double noderadius;
    bool is_oddvert;		// is vertex odd or even?

	Medcoord uvt;			// texture/medial-correspondence coordinates

	DbVector3 true_nodeloc;
	DbVector3 true_nodenorm;

	subgridnode() { ; }

	subgridnode & operator=(const subgridnode& s1) {
		nodenorm = s1.nodenorm; nodeloc = s1.nodeloc; noderadius = s1.noderadius;
		is_oddvert = s1.is_oddvert;
		uvt	= s1.uvt;
	//	true_nodeloc = s1.true_nodeloc;
	//	true_nodenorm = s1.true_nodeloc;
		return *this;
	}
	void zerovals() { nodeloc = NULLVEC; nodenorm = NULLVEC; noderadius = 0; }
	// NOTE:  setvals doesn't change is_oddvert
	void setvals(const DbVector3& loc, const DbVector3& norm, double radius,
		         double u, double v, double t) {
		nodeloc = loc; nodenorm = norm; noderadius = radius;
		uvt.u = u; uvt.v = v; uvt.t = t;
	}
};

typedef struct {
    subgridnode *topgrid;
    subgridnode *bottomgrid;
    subgridnode *sidegrid;
    int subnumrows, subnumcols; // number of top and bottom rows and columns
    int edgelength; // 2*numcols + 2*numrows - 4
    int sidenumrows, sidenumcols;
} subdivgrid;

typedef GLfloat Fastvec[3];

typedef struct {
    int nquads;
    Fastvec *vertlist;
	Fastvec *normlist;
	double *radiuslist;
	Medcoord *uvtlist;
	bool initialized;
} subdivRenderObj;

// The following are datastructures for Vertex neighbor lists needed for
typedef enum { TOP, BOTTOM, SIDE } MeshID;

typedef struct {
	MeshID whichmesh;
	int meshindex;
} Meshneighbor;

// Only [0..valence-1] are defined for a given vertex
//   Neighbors are listed in counterclockwise order e1-v1-e2-v2-...vn
class Vertexneighbors
{
	Meshneighbor neighbors[8];
	int valence;
public:
	Meshneighbor& operator[](int val) { return neighbors[val]; }
	int& degree() { return valence; }
};

// create lists of vertex neighbors for subdivgrids of a given subdivision level
//   for use in creating limit-point subdivgrids
typedef struct {
	Vertexneighbors *topneighbors;
	Vertexneighbors *bottomneighbors;
	Vertexneighbors *sideneighbors;
	bool initialized;
} Subneighborhood;

// NUMSUBLEVELS gives subdivision meshes 0 (base mesh) through (NUMSUBLEVELS -1)
const int NUMSUBLEVELS = 7;

/********************************************************************************/
/* Class Subdivsurf: 															*/
/*																				*/
/* Handles creation and drawing to the raster by Shapemonger routines, at the	*/
/* high level---actual rasterization and maintenance of transformation matrices */
/* will take place in Shaperaster, to allow for OpenGL rasters as a transparent */
/* plug-in.						 												*/
/********************************************************************************/
class Subdivsurf {

	// Variability of angle between model spoke vectors and surface tiles
	double theta_tol_deg;

    // pointers to figure's grid and STATE variables
    Diatomgrid *fig_grid;

    // subdivgrids for vertices, normals, textureccords, etc.
    subdivgrid sub[NUMSUBLEVELS];
	PseudoSet involuteset_top[NUMSUBLEVELS];
	PseudoSet involuteset_bottom[NUMSUBLEVELS];
	PseudoSet involuteset_side[NUMSUBLEVELS];

	// nearvertices store 8/6 neighborhoods for sub[subdivlevel] vertices
	Subneighborhood vneighborhoods[NUMSUBLEVELS];
	void get_vneighborhoods(int subdivlevel);

	// compute_limitpoint() -- uses Catmull-Clark rules to compute limit position
	//    and normal for an even meshpoint in a 6 or 8 neighborhood.
	void compute_limitpoint(int dex, subdivgrid *submesh, Subneighborhood *nhoods,
							MeshID selectedmesh, subgridnode *thisgridnode);
	// create_limit_mesh() -- uses Catmull-Clark rules to compute limit-mesh based
	//   on input subdivgrid.
	subdivgrid *create_limit_mesh(int subdivlevel);

	///////////////////////////////////////////////////////////////////////////////
	// Stuff for inverse-mapping limit points to create perturbed subdivgrid
	void compute_inverselimitpoint(int dex, subdivgrid *submesh, Subneighborhood *nhoods,
								   MeshID selectedmesh, subgridnode *thisgridnode);
	// This does a second level iteration, using computed_inverse mesh but original
	//   boundary position
	void compute_inverselimitpointLEVEL2(int dex, subgridnode *oldnode, subdivgrid *submesh,
										 Subneighborhood *nhoods,
									     MeshID selectedmesh, subgridnode *thisgridnode);
	subdivgrid *inverse_limit_mesh(int subdivlevel);
    ///////////////////////////////////////////////////////////////////////////////

	// create_normalinterpolating_mesh() -- for a level-2 mesh, compute a new mesh that
	//		interpolates .true_nodenorm values at involute points stored in involutesets.
	//		At level two, all 1-neighborhoods are disjoint
	// It is an error to call this function if the level-2 mesh has not already been
	//		computed.
	// MODIFICATION:  this now operates in-place on sub[2] mesh, avoiding an O(#vertices)
	//    copy operation.
	void create_normalinterpolating_mesh();

	// Pointer to subdivgrid currently selected for rendering/pointlisting
	subdivgrid *activesubmesh;

	// Pointer to limitsubmesh, holds limit surface for a given level of subdivision
	subdivgrid *limitsubmesh;

    //pointers to quadlist/texturecoordlist/normallist structs
    subdivRenderObj *subrast[NUMSUBLEVELS];

	// indices from current subdivRenderObj tilelist into list of bpoints
	//    returned by Subdiv_boundaryinfo()
	int *tileindices;

	// fix side indices so that top and bottom edge of side point to edges of
	//    top and bottom grid-vertices, since duplicating top and bottom edges of sides
	//    not included in pointlist returned
	void fix_side_edges(int *indexlist, int ntiles, int nrows, int ncols, int nscols, int nsrows);

    // modify the segmentlists in the given displaylist objects,
    //   --redraw only after all have been modified, with call to SelectDiatom()
    void mod_subdiv(int meshchoice);

	// draw the given subdivRenderObj using OpenGL commands
	void GLsubdraw(subdivRenderObj *subobj, RenderStyle choice = WIREFRAME);

    // It is an error to call these out of order...fillsubmesh0, followed by
    //   meshlevels 1, 2, 3,..., (NUMSUBLEVELS - 1)
    void fillsubmesh0();
    void split(int meshlevel);
    void averaging(int meshlevel);

public:
	// Constructor (Diatomgrid defined in Diatom.h)
    Subdivsurf(Diatomgrid *thisgrid = NULL);
    ~Subdivsurf();

	void setSmoothness(int val) { theta_tol_deg = (double) val; }

    // Subdivision surfaces---spit out OpenGL commands to render subdivision surface
    //   of level (0 <= n < NUMSUBLEVELS), rendering either vertex points, wireframe, 
	//   or filled polygon RenderStyles
    void GLrendersubdiv(int n, RenderStyle choice);

	// returns pointer to internal list of quad-tiles, each stored as 4 sequential
	//   Bpoints.  numtiles gives # of such 4-Bpoint tiles
	//   NOTE:  Bptlistptr is created here, but control (and deletion of) passed to
	//    calling routine
	//   NOTE:  to use, first call GLrendersubdiv(subdivlevel, NO_RENDER)
	void Subdiv_tileinfo(int subdivlevel, int *ntiles, Bpoint **bptlistptr,
		                 int *num_ucoltiles, int *num_vrowtiles, int *num_t_tiles);

	// same as above, but gives only individual vertices on boundary,not tiles
	void Subdiv_boundaryinfo(int subdivlevel, int *npoints, Bpoint **bptlistptr);

	// returns tilelist generated by Subdiv_tileinfo() as quads of indices into
	//    list returned by Subdiv_boundaryinfo(), rather than explicit Bpoints
	void Subdiv_tileindices(int subdivlevel, int **subdivtileindices);

	// create neighborlist associated with tileset produced by mod_subdiv()
	//    for current activesubmesh.  Contains a list of ntiles Tileneighbors arrays,
	//    each giving index values associated with neighbors of indexing tilenumber.
	//    Tileneighbors (int[8]) typedefed above.
	//    If fewer than 8 neighbors, last elements in list will be == -1.
	void get_tileneighbors(int *ntiles, Tileneighbors **neighborlist);

	// create neighborlist associated with vertices produced by mod_subdiv()
	//    for current activesubmesh.  Contains a list of nverts Tileneighbors arrays,
	//    each giving index values associated with neighbors of indexing vertexnumber.
	//    Tileneighbors (int[8]) typedefed above.
	//    If fewer than 8 neighbors, last elements in list will be == -1.
	// Vertices are in counterclockwise order starting with an edge vertex
	//    (See def of class Tileneighbor above)
	bool get_vertexneighbors(int subdivlevel, int *nverts, Tileneighbors **neighborlist);

	// spit out OpenGL commands to render the diatom mesh or its involute vectors
	void GLrendermesh();
	void GLrenderv1v2b();
	void GLrenderv1v2bTOL();

    // Recompute the entries in the quadlists already loaded into
    //   the subdivRenderObj
    void ModGrids();

	// Create a new subdivision surface based on the figure-grid read from the given file
	//   This ignores any state-information
	bool read_mfig(FILE *infile);

	// Create a new subdivision surface based on the given file, and output it as a .m3d file
	//   This uses state-information to get global positioning for output
	spatialstate globalloc, modelcoords;
	void modify_Diatom(Diatom& atom);
	bool read_mfig_output_m3d(FILE *infile);
	bool output_m3d(const char *outfile);

	// return a pointer to the Diatomgrid (to use when initializing interpolated figure
	Diatomgrid *Diatomgridptr() { return fig_grid; }
};

