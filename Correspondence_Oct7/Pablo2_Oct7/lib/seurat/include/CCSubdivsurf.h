#ifndef CCSUBDIVSURF_HDR
#define CCSUBDIVSURF_HDR

/****************************************************************************/
/*																			*/
/*  	File	:  CCSubdivsurf												*/
/*																			*/
/*	Description:  class declaration for CCSubdivsurf, a standalone class	*/
/*		creating and OpenGL rendering of subdivision surfaces as wireframes	*/
/*		given an initializing Mfig model. (single figure)					*/
/*																			*/
/*		This is meant to replace Subdivsurf.h., ultimately, but for now,	*/
/*		uses Subdivsurf output to Pointlist_server2 to set adjacency info	*/
/*		for quads and vertices for the initial mesh.						*/
/*																			*/
/*	Project :  Seurat														*/
/*																			*/
/*	Author  :  A. Thall														*/
/*																			*/
/*	Date	:  5. July 2002													*/
/*																			*/
/*	Modifications:															*/
/****************************************************************************/
#include <stdio.h>

typedef int CCVindex;
typedef int CCPindex;
const int NULLPOLYDEX = -1;
const int NULLVERTDEX = -1;

typedef MyList<CCVindex> VindexList;
typedef MyList<CCPindex> PindexList;

class CCVertex
{
public:
    DbVector3 loc; 		// location
	DbVector3 norm;
	double rad;
    bool is_oddvert;		// is vertex odd or even?

	Medcoord uvt;			// texture/medial-correspondence coordinates
	short v_valence;

	DbVector3 limitloc;		// location and normal of vertex on limit surface
	DbVector3 limitnorm;
	double limitRad;

	DbVector3 true_loc;		// Involute location and normal for original
	DbVector3 true_norm;	//    involute vertex.  Probably replace these

	CCVertex() 
	{ 
	}

	~CCVertex() 
	{ 
	}

	CCVertex& operator=(const CCVertex& s1) 
	{
		norm = s1.norm; loc = s1.loc; rad = s1.rad;
		is_oddvert = s1.is_oddvert;
		uvt	= s1.uvt;
		v_valence = s1.v_valence;
		true_loc = s1.true_loc;
		true_norm = s1.true_loc;
		return (*this);
	}
	void zerovals() 
	{
		loc = NULLVEC; 
		norm = NULLVEC; 
		rad = 0.0; 
	}

	void setvals(const DbVector3& loc1, const DbVector3& norm1, double crad1 ,
		const Medcoord& uvt1, short vvalence, bool isoddvert) 
	{
		loc = loc1; norm = norm1; rad = crad1;
		uvt	= uvt1;
		v_valence = vvalence; is_oddvert = isoddvert;
	}
	void setvalenceandoddflag(short vvalence, bool isoddvert)
	{
		v_valence = vvalence; is_oddvert = isoddvert;
	}

	void settruevals(const DbVector3& trueloc, const DbVector3& truenorm) 
	{
		true_loc = trueloc;
		true_norm = truenorm;
	}

	void printvals(char *message = NULL);
};

class CCPolygon
{
public:
	MyList<CCVindex> Pvertices;
	MyList<CCPindex> Pneighbors;
	MyList<short> Pneighboredges;

	CCPindex parentPolygon;		// index of parent Polygon in CCmesh generating this one
	MyList<CCPindex> childPolygons;   // index of child Polygons being generated by this one

	CCVindex newfacevert;			// Computed during splitting-averaging
	MyList<CCVindex> newedgeverts;  //   and given as a pointer into new vertex,
	                                //   ordered by the edge-number.

	CCPolygon() 
	{
	}
	~CCPolygon()
	{
		DestroyCCPolygon();
	}
	void DestroyCCPolygon()
	{
		Pvertices.Destroy();
		Pneighbors.Destroy();
		Pneighboredges.Destroy();
		childPolygons.Destroy();
		newedgeverts.Destroy();
	}

	CCPolygon& operator=(CCPolygon& poly1);

	int numsides() { return Pvertices.Length(); }

	void printvals(char *message = NULL);
};

/********************************************************************************/
/* Class CCMesh -- child vertices are always in the same position in VertList	*/
/*	  as they were in the parent list.											*/
/********************************************************************************/
class CCMesh
{
public:
	MyList<CCVertex> VertList;
	MyList<CCPolygon> FaceList;

	MyList<PindexList> VertFaceNeighbors;	// Give adjacent Faces to this vertex, in counterclockwise order
											// from the exterior, indexed by VertList index
											// NOTE: valence of vertex i is number of VertFaceNeighbors[i]
											// NOTE: vertex i is regular if all VertFaceNeighbors[i] have 4 sides
	MyList<PindexList>VertFaceNeighborsVert;// Give index of this vertex in adjacent Faces as listed above
//	MyList<PindexList> FaceFaceNeighbors;	// Give adjacent Faces to this face, in counterclockwise order
//											   from the exterior, indexed by FaceList
	// For now, not using FaceFaceNeighbors

	CCMesh() 
	{ 
	}
	~CCMesh()
	{
		DestroyCCMesh();
	}
	void DestroyCCMesh()
	{
		int i;
		VertList.Destroy();
		for(i=0; i<FaceList.Length(); i++)
		{
			FaceList(i)->DestroyCCPolygon();
		}
		FaceList.Destroy();
		for(i=0; i<VertFaceNeighbors.Length(); i++)
		{
			VertFaceNeighbors(i)->Destroy();
		}
		VertFaceNeighbors.Destroy();		// Give adjacent Faces to this vertex, in counterclockwise order
		for(i=0; i<VertFaceNeighborsVert.Length(); i++)
		{
			VertFaceNeighborsVert[i].Destroy();
		}
		VertFaceNeighborsVert.Destroy();	// Give index of this vertex in adjacent Faces as listed above	
	}

	int nedges;
	int numverts() { return VertList.Length(); }
	int numfaces() { return FaceList.Length(); }
	int numedges() { return nedges; }	// numedges is 1/2 the sum of the number of sides of the faces

	// Compute the vertex that regularizes the given polygon
	//   with <> 4 sides, about the indexed Pvertex
	// See Ch. 4 of Thall Diss for details
	DbVector3 regularize(CCPindex thispolydex, int pvdex);
 	double regularizeR(CCPindex thispolydex, int pvdex);
};

typedef enum { TRITORUS, FIGURE8, PYRAMID, CUSTOMIZED, FROMFILE } TestMeshShape;

// NUMSUBLEVELS gives subdivision meshes 0 (base mesh) through (NUMSUBLEVELS -1)
const int NUMLEVELS = 7;
const int MAXVALENCE = 32;	// maximum number of faces (used to initialize tables for limit meshes)
const int DEFAULT_NUMITER = 8; // default number of iterations to create IIS mesh

/********************************************************************************/
/* Class Subdivsurf: 															*/
/*																				*/
/* Handles creation, subdivision (with various interpolation) and rasterization */
/*		of hierarchy of CCMeshes.												*/
/********************************************************************************/
class CCSubdivsurf
{
	CCMesh fathermesh;			// This is the input mesh
	                            //   or the perturbed parentmesh for interpolation
	void initpyramid();
	void inittritorus();
	void initfigure8();
	void initcustomized();
	void initfromfile();

	double MyRand(double low, double high);

	// for limitsurfaces, tabulate values for edge and face weights
	//    E[n][j] = weight for edge_j for valence n, for j=1 to n
	//    F[n][j] = weight for face_j (counterclockwise from edge i)
	//                for valence n, for j = 1 to n
	// (some wasted space, but don't want to do more indexing arithmetic)
	static double Etable[MAXVALENCE + 1][MAXVALENCE + 1];
	static double Ftable[MAXVALENCE + 1][MAXVALENCE + 1];
	void init_tables();

	int **vTag, **fTag;

	double theta_tol;

	float lineDotWidth;
	bool isTubeMesh;
public:
	MyList<CCMesh> submeshes;	// submeshes[0] is either copy of the parentmesh

public:
	// Constructor (Diatomgrid defined in Diatom.h)
    CCSubdivsurf(int numlev = NUMLEVELS) 
	{ 
		// by default, we are not interpolating the normals
		// therefore the surface is as smooth as it can get from subdivision
		theta_tol=M_PI;

		submeshes.Create(numlev); 
		init_tables(); 

		lineDotWidth=1.0;
	
		isTubeMesh=false;
	}
    ~CCSubdivsurf() 
	{ 
		int i;
 		fathermesh.DestroyCCMesh();
		for(i=0; i<submeshes.Length(); i++)
		{
			submeshes(i)->DestroyCCMesh();
		}
		submeshes.Destroy();
		/*
		Pvertices.Destroy();
		Pneighbors.Destroy();
		Pneighboredges.Destroy();
		childPolygons.Destroy();
		newedgeverts.Destroy();
		*/
	}

	void setLineDotWidth(float width = 1.0) { lineDotWidth = (float) width; }

	// Pass in a Bpoint list of initial boundary involutes and an array of Pindexlists
	//    giving the polygons associated with the pntlist vertices.
	// This will load fathermesh with the vertices and polygons, and compute
	//    all connectivity information for the initial CCMesh objects
	void init(int numverts, int numfaces, Bpoint *pntlist, PindexList *faces);
	void initdummy(TestMeshShape = PYRAMID); // create a parent-mesh with a simple pyramid with a 4-sided base

	void InitValue(int numverts, Bpoint *pntlist);
	void InitTopology(int numverts, int numfaces, Bpoint *pntlist, PindexList *faces);


	CCMesh *SubMeshPointer(int subLvl); // return the pointer to the submesh

	void loadlevelzero();	// This simply copies values from Parentmesh into submeshes(0);

	void LoadLevelZeroValue();

	//void perturblevelzero(); // This modifies submeshes(0) so that in the limit, it will
	                         //   interpolate Parentmesh

	void perturbleveltwo(); // This modifies submeshes(2) so that, in the limit, it will
	                        // match normals with Parentmesh

	bool splitandaverage(int nivelo);	// Split the given level to create the next
	//bool splitandaverageUPDATE(int nivelo); // Modify values only, leave connectivity unchanged

	void Subdivide(int nivelo);
	void Interpolate(int nivelo);

	// Compute the limit mesh for the given submesh level, returns false if level not computed
	bool computelimitmesh(int nivelo);	

	// Iteratively compute a submeshes(0) that interpolates fathermesh in the limit
	//    returns false if not initialized.
	bool computeIISmesh(int numiter = DEFAULT_NUMITER); 

	//bool modifyCCVertex(int nivelo, CCVindex vertnum, CCVertex& newvert);

	void glRender(int nivelo, RenderStyle thisstyle = WIREFRAME);

	void SubdivBoundaryInfo(int subLvl, int *npoints, Bpoint **bptlistptr);
	bool GetVertexNeighbors(int subLvl, int *nverts, Tileneighbors **neighborlist);

	// return the new neighboring vertex list for the area calculation in Mask
	bool GetNeighboringVertices(int subLvl, NeighborVertices **nVertices);

	void GetTileNeighbors(int subLvl, int *ntiles, Tileneighbors **neighborlist);
	bool GetTileIndices(int subLevel, int **subdivtileindices);

	//void GetTileNeighbors(int *ntiles, Tileneighbors **neighborlist);
	//void SubdivTileIndices(int subdivlevel, int **subdivtileindices);
	void SubdivTileInfo(int subdivlevel, int *ntiles, Bpoint **bptlistptr);//, int *num_ucoltiles, int *num_vrowtiles, int *num_t_tiles);

	bool WriteCMesh(int lvl, int vNumBase);

	void initBlending(int numverts, int numfaces, Bpoint2 *pntlist, PindexList *faces);
	void loadlevelzeroBlending();	// This simply copies values from Parentmesh into submeshes(0);
	void loadlevelzeroPureSmoothing();

	// blending stuff
	int vRedex[2000];			// a re-index of all the vertices in the new mesh
	int vFlag[2000];
	int vFaceReduction;		// the # of face vertices in the new mesh that should be removed
	int vEdgeReduction;		// the # of edge vertices in the new mesh that should be removed

	//bool CCSubdivsurf::splitandaverageBlending(int nivelo, int *vTag, int *fTag)
	bool splitandaverageBlending(int nivelo, int *vTag, int *fTag);	// Split the given level to create the next
	bool splitandaverageBlending_1(int nivelo);	// Split the given level to create the next
	bool splitandaverageBlending_2(int nivelo);	// Split the given level to create the next
	bool computeIISmeshBlending(int numlvl, int numiter=DEFAULT_NUMITER); 
	void glRenderBlended(int nivelo, RenderStyle thisstyle=WIREFRAME);
	//bool computeFatherMeshBlending(ThallCode::Pointlist_server2 **pList);

	bool computelimitmeshBlending(int nivelo);

	// debug purpose: to test the correctness of the inverse algorithm with arbitrary quad mesh
	bool computeIISmesh(int numlvl, int numiter); 

	// debug purpose: to test the correctness of the inverse algorithm with arbitrary quad mesh
	bool computeIISmesh2(int numlvl, int numiter=DEFAULT_NUMITER); 

	void glRenderBlendedObject(int nivelo, RenderStyle thisstyle = WIREFRAME);

	// functions for debugging purpose
	void glRenderSurfaceNormals(int nLvl);
	//void glRenderVerticesNormals(int nLvl);
	void glRender(int nivelo, int polyDex, RenderStyle thisstyle=WIREFRAME, MyFloat *c=NULL);
	void glRender(int vNum, int fNum, Bpoint2 *vList, PindexList *fList, RenderStyle thisStyle, MyFloat *c=NULL);
	void glRenderCurve(int startPDex, int endPDex, Bpoint2 *pntList, MyFloat *c);
	void glRenderSegments(int startPDex, int endPDex, Bpoint2 *pntList, MyFloat *c);
	void glRenderPoint(Bpoint2 pnt, MyFloat *c);
	void CompareNormalsFromVerticesAndFromSubdivision(int meshLvl);

	// to deal w/ the smoothness parameters
	void setSmoothness(int val) { theta_tol = ((double) val)*M_PI/180.0; }

	// to deal with tubular m-rep
	void setIsTubeMesh(bool _isTubeMesh) { isTubeMesh=_isTubeMesh; }
	bool getIsTubeMesh() { return isTubeMesh; }
	// FIXME: TODO: NEED TO work this out for tubes - gst/rrs/eli
	//added for Eli for atom regions
    bool computeLvl0VertAtomList(int numRows, int numCols, int *list);
};

#endif

