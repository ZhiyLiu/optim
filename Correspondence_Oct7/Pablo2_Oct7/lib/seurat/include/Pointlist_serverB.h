
/********************************************************************************/
/*                                                                              */
/*      File    :  Pointlist_serverB.H											*/
/*                                                                              */
/*      Description:  class definition for new PointCloud pointlist server,		*/
/*			which takes an Xferlist or Subdivsurf, copies the Diatomgrid, and	*/
/*			and returns points, normals, and radii of the surface near a Diatom */
/*			given an interpolation of the medial mesh to generate a dense		*/
/*			pointset, but NOT generating a smooth subdivision surface.			*/
/*																				*/
/*		NOTE:  We use a scaled, shifted cosine to generate multiplier			*/
/*			between [1, eta] for the radii on endcaps.							*/
/*                                                                              */
/*      Project :  Seurat                                                       */
/*                                                                              */
/*      Author  :  A. Thall, S. Joshi                                           */
/*                                                                              */
/*      Date    :  3. June 2000													*/
/*                                                                              */
/*      Modifications:                                                          */
/*			17. July -- added ComputeBoundaryTiles(), glRenderTiles(), and		*/
/*				tileinfo()														*/
/*			18. July -- added ComputeTilePointCloud()							*/
/*			7. Aug -- (Joshi & Thall) added (u, v, t) parameter to Bpoint and	*/
/*				relevant routines.												*/
/*			10. Aug -- added Bposition(u, v, t) providing a look-up for 		*/
/*				boundary positions												*/
/*			11. Aug -- changed gridsubdivrows=0 to rowspacing=1 for no			*/
/*				subdivision, and likewise gridsubdivcols to colspacing=1		*/
/*				Changed meshsubdivrow= 0 to meshrowspacing=1, & likewise		*/
/*			4. Dec 00 -- changed alphafun() to etafun()							*/
/*			7. Dec 00 -- also merged in some partial-rendering code from Graham */
/*				Gash's version of older Seurat in Pablo.						*/
/*			29. Jan 01 -- Added update_mesh() to modify internal Diatomgrid		*/
/*				and update Interpolfig object.									*/
/*			2. May 01 -- Added subdivtileset and numsubdivtiles, for Bpointlist */
/*				generated by the boundary of a Subdivsurf called on the			*/
/*              interpolation-subdivided workgrid.								*/
/*				Added functions ComputeSubdivBoundaryTiles()					*/
/*								ComputeSubdivPointCloud()						*/
/*                          and SubdivTileInfo()								*/
/*                          and SubdivBoundaryInfo()							*/
/*				to create and access these subdivision surface boundary lists	*/
/*				(Added subdivbpoints and subdivnumpoints for vertex lists.)		*/
/*			5. May -- added subdivtileneighbors() to return tile-indexed list	*/
/*				of neighboring tile indices (See Class Tileneighbor in			*/
/*				Subdivsurf.h, simply int array of indices)						*/
/*				Added Tileneighbors *tneighbor as class member					*/
/*				Modified ComputeSubdivBoundaryTiles to compute tneighbor list.	*/
/*			3. Aug 01 -- added subdivNearpoint() functions,						*/
/*				which return (u, v, t)  and (x, y, z) coords for the			*/
/*				nearest point on the subdivided surface (at given level of		*/
/*				interations) to an external (x0, y0, z0).						*/
/*				NOTE:  this should be able to return a vector of such values	*/
/*			8. Aug 01 -- added subdivNearSurface(), which finds the bilinearly	*/
/*				interpolated point on the nearest tile with a Phong-normal		*/
/*				nearest the point (x0, y0, z0) in angle							*/
/*          13. Aug 01 -- added num_ucoltiles, num_vrowtiles, num_t_tiles to	*/
/*				hold data on subdivision tileset needed for indexing of (u,v,t) */
/*			    values.															*/
/*			14. Aug -- added subdivBposition() to return Bpoint on the tiled	*/
/*				subdivision generated boundary corresponding to a given (u,v,t) */
/*			    Added interpolate_quad() to slice a quad of Bpoints (counter-	*/
/*				-clockwise order) into two triangles and bilerp across them,	*/
/*				chosing upper (a,d,c) if u (vertical) > v (horizontal).			*/
/*			9. Sept -- added interpolate_quad2(), and altered interface to		*/
/*				subdivNearSurface() to return boolean for success and to		*/
/*				give a Bpoint and a distance on success.						*/
/*          23. Sept -- added subdivNearSurfaceSIDED(), as above but only		*/
/*				searches tiles on top (TOP_p) or bottom (!TOP_p) tilesheet,		*/
/*				and ignores crest tiles.  This used for finding corresponding	*/
/*              involutes and medial atoms for a given surface Bposition.		*/
/*			    Added subdivMedialStuff() to return medial atom and opposing	*/
/*				boundary position corresponding to an input Bposition.			*/
/*			26. Sept -- modified subdivNearSurfaceSIDED to select using			*/
/*				the new searchSIDE enum, including the crest tiles.				*/
/*			 2. Oct -- added outsideFLAG parameter to subdivNearSurface()		*/
/*				which is set if passed a non-NULL value, else no action taken.	*/
/*			12. Nov -- added subdivvertexneighbors() to get vertex neighborlist	*/
/*					added Tileneighbor *vneighbors with vertex neighbors.		*/
/*			    Dec 01 -- modified glRenderSubdivTiles() with a displacement	*/
/*					term to perturb boundary toward medial axis.				*/
/*			23. Jan 02 -- added subdivtileindexinfo()							*/
/*                               copySubdivTileIndexInfo(),						*/
/*					 returns list of quad-tiles									*/
/*					as sets of 4 indices into bptlist of vertices returned		*/
/*                  by subdivboundaryinfo()										*/
/*				copySubdivTileInfo() was changed to return ntiles, not number   */
/*					of points in list (== ntiles*4).							*/
/*				added int *subdivtileindices list for above						*/
/*			11. Apr 02 -- updated with new Nearpoint-finding code				*/
/*			24. June 02 -- eliminated workgrid, all interpolfig code			*/
/********************************************************************************/

//typedef enum { TOPSIDE, TOPCREST, BOTTOMCREST, BOTTOMSIDE } searchSIDE;
typedef std::queue<int> IntQueue;
typedef std::set<int> IntSet;


class Pointlist_serverB
{
//	bool subdivSurfInitialized;

	// New lists for subdivsurf derived bpoints and tilesets
	Bpoint *subdivbpoints;
	int numsubdivpoints;
	Tileneighbors *vneighbors;	// neighboring vertex list

	Bpoint *subdivtileset;
	int numsubdivtiles;
	int num_ucoltiles, num_vrowtiles, num_t_tiles;
	Tileneighbors *tneighbors;	// neighboring tile list

	// as above, but indices of tileset vertices into subdivbpoints list
	int *subdivtileindices;

	// gives an eta multiplier between 1 and eta for mesh edge boundary pts
	double etafun(double eta, double theta, double rotangle);

	const float * color1;
	const float * color2;
	float color3[3];

	// keep track of last tile on which a nearpoint was found as initializer
	//   for next search
	PseudoSet OldnearsetA;
	PseudoSet nearset;        // set container for int value
	PseudoSet neighborset;		// Check neighbors of OldnearsetA tiles if none of them are possible
	PseudoSet neighborset2;
	PseudoSet neighborset3;

	PseudoSet OldnearsetB;	// Separate OldnearsetB for subdivNearSurfaceSIDED()

	int smoothness;		// Variability of angle between spoke vectors and surface tiles

	CCSubdivsurf* thisSurf;

	int currentBoundaryTilesLevel;
	int currentPointCloudLevel;

	int figureNum;
	//Diatomgrid **newGrid;
	Pointlist_server2 **pListOriginal;

    const M3DObject * object;
    M3DObject * subObject;
	void (* check)(void);
    float cubeSize;
	int level;
	int numTrees;

	float * blendExtents;
	float * blendAmounts;

//	static std::vector<ThallCode::Pointlist_server2 *> tileLists;

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	MyFloat create_plist(M3DFigureTreeNode * node);
	MyFloat linearize(M3DFigureTreeNode * node);

	//int LookUpPDexByUVT(ThallCode::Pointlist_server2 *pList, Bpoint2 pt);

	// the min-segment-square is dynamically determined by the relative # of points on the cut-curve
	void RegularizeDilatedIntersectionCurve(int numPoints, Bpoint2 *newC, Bpoint2 *oldC, int *pNum);

	// the min-segment-square is pre-set as some contants
	void RegularizeDilatedIntersectionCurve(Bpoint2 *newC, Bpoint2 *oldC, int *pNum);

	void RegularizeIntersectionCurveUVT(MyFloat uMaxM, MyFloat vMaxM, MyFloat uMaxS, MyFloat vMaxS, Bpoint2 *curv, int pNum);
	//, pListOld[0]->max_u(), pListOld[0]->max_v(), pListOld[1]->max_u(), pListOld[1]->max_v(),	interCurve, interPNum);

	///*
	// the min-segment-square is determined by the relative # of points on the cut-curve
	void RegularizeIntersectionCurve(int numPoints, Bpoint2 *newC, Bpoint2 *oldC, int *newPairs, int *oldPairs, int *pNum);

	// the min-segment-square is pre-set as some contants
	void RegularizeIntersectionCurve(Bpoint2 *newC, Bpoint2 *oldC, int *newPairs, int *oldPairs, int *pNum);
	void RegularizeIntersectionCurve(MyFloat vMaxS, Bpoint2 *newC, Bpoint2 *oldC, int *newPairs, int *oldPairs, int *pNum);

	bool SamePoint(MyFloat epsilon, Bpoint p1, Bpoint p2);
	bool SamePoint(MyFloat epsilon, Bpoint2 p1, Bpoint2 p2);

	bool SamePointByDistance(MyFloat epsilon, Bpoint2 p1, Bpoint2 p2);
	bool SamePointByDistanceSquare(MyFloat epsilon, Bpoint2 p1, Bpoint2 p2);

	void ConvertCoordinates(MyPoint2D *c2D, Bpoint2 *c, MyFloat mU, MyFloat mV, int pNum);
	void DilatePoint(Bpoint2 *pnt, MyFloat maxU, MyFloat maxV, MyFloat deltaU, MyFloat deltaV);
	void CalculateDilationDirection(MyPoint2D *c2D, Bpoint2 *c, MyFloat mU, MyFloat mV, int pNum);
	bool DilateCurve(ThallCode::Pointlist_server2 *pList, Bpoint2 *curv, int pNum, MyFloat dt, int steps);
	//*/

	//CheckIntersectionCurveOrientation(subInterCurve, subInterPNum, interCurve, interPNun);
	bool CheckIntersectionCurveOrientation(Bpoint2 *subC, int subPNum, Bpoint2 *intC, int intPNum);

	bool ConvertUVT2XY_Bottom(int type, int area, Bpoint2 curv, MyPoint2D *curv2D, MyFloat maxU, MyFloat maxV);
	bool ConvertUVT2XY_Crest(int type, Bpoint2 curv, MyPoint2D *curv2D, MyFloat maxU, MyFloat maxV);

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////

public:
	bool subdivSurfInitialized;

	// inline constructor and destructor---see below
	Pointlist_serverB();
	~Pointlist_serverB();

	// initialize the Pointlist_serverB, passing in either an Xferlist
	//	  or an already created Subdivsurf; this creates a local newgrid
	//	  mesh{rows,cols}spacing gives number of sections per initial meshgrid
	//	  (default = 1 gives just original mesh atoms).  The first function
	//	  sets the smoothness angle from the Xferlist; with the second function,
	//	  use setSmoothness() to do this.  A default smoothness of 0 is set in
	//	  the constructor.

	void init(const M3DObject *obj, int subLevel = 1);

	bool ValidFigureID(int figureId){ return (figureId>=0 && figureId<figureNum); }
	// Functions to change the internal Diatomgrid  with the new atom's values
	void update_mesh(int figureId, XferAtom *thisatom, int Xfer_col, int Xfer_row);
	void update_mesh(int figureId, Diatom *thisatom, int u_col, int v_row);


	void setSmoothness(int val) { smoothness = val; }

	// Compute bpointlist of subdivision surface boundary generated from initial
	//    diatomgrid interpolated to mesh{row,col}spacing and then sent to Subdivsurf
	//    for Subdivision 0 <= subdivlevel <= 6 and then output of resulting tiles
	//    to subdivtileset
	//void ComputeOverallBlendingBoundaryTiles(int subdivlevel = 2);

	// initialize bpoints[] with boundary involutes of the atoms of 
	//   the medially-subdivided mesh---these would be vertices of
	//   the boundary tiles computed by ComputeBoundaryTiles().
	// NOTE:  there is NO REDUNDANCY in this list
	//void ComputeOverallBlendingPointCloud(int subdivlevel = 2);

	// Returns a pointer to the internal list of 8 tile numbers adjacent to the
	// specified tile number.
	void adjacencyList(int tile, Tileneighbors **adjlistptr) {
		*adjlistptr = tneighbors + tile;
	}
	// Returns a pointer to the entire, internal adjacency list computed above.  The
	// length will be 8 times the number of tiles.
	//void adjacencyinfo(int *length, short **adjlistptr);
	// returns pointer to internal list of subdivsurf generated boundary vertices
	void subdivboundaryinfo(int *numpoints, Bpoint **bptlistptr);
    // Same as above, but returns a copy, not a pointer to internal array
    void copySubdivBoundaryInfo(int * numpts, Bpoint **bptlistptr);
	// returns pointer to internal list of quad-tiles produced by Subdivsurf
	void subdivtileinfo(int *ntiles, Bpoint **bptlistptr);
	// Added by Tom, does same as above but returns a copy, not the internal
    // Also returns number of points not tiles
    void copySubdivTileInfo(int * numpts, Bpoint **bptlistptr);
	// returns list of quad-tiles as sets of 4 indices
	//    into bptlist of vertices returned by subdivboundaryinfo()
	void subdivtileindexinfo(int *ntiles, int **vertlistptr);
	// as above, but makes copy of internal list
	void copySubdivTileIndexInfo(int *ntiles, int **vertlistptr);
	// returns pointer to internal list of Tileneighbors, indexed by tilenumbers
	//    from above list.  It is an error to call this before calling 
	//    ComputeSubdivBoundaryTiles() or ComputeSubdivPointCloud()
	//    Not of much use without the tilelist, anyway.
	void subdivtileneighbors(int *ntiles, Tileneighbors **neighbors);
	// returns pointer to internal list of Vertexneighbors, indexed by vertexnumbers
	//    from above list.  It is an error to call this before calling 
	//    ComputeSubdivPointCloud() Not of much use without the vertexlist, anyway.
	void subdivvertexneighbors(int *nverts, Tileneighbors **neighbors);

	// return the nearpoint(s) on the surface---return value is the distance itself
	double subdivNearpoint(double x0, double y0, double z0, 
		                   DbVector3 *nearpointXYZ, DbVector3 *nearpointUVT, int *multiplicity);
	double subdivNearQuads(double x0, double y0, double z0, 
		                   DbVector3 *nearpointXYZ, DbVector3 *nearpointUVT, int *multiplicity);

	// return bool for success, and load Bpoint with surface position and neardist with distance
	//    from (x0, y0, z0) to that position.  If outside_FLAG != NULL, set true if point found
	//    to be outside object, else false
	bool subdivNearSurface(double x0, double y0, double z0, Bpoint *nearpoint, double *neardist,
		                   bool *outsideFLAG = NULL);
	// Clears Oldnearset cache used in above, reinitializes to prevent lock on old value
	//    when a new location may be closer
	void clear_cache() { OldnearsetA.clear(); }

	// as above, but only searches tiles on tilesheet selected by searchSIDE testside
	//    This used for finding corresponding involutes and medial atoms for a given 
	//    surface Bposition.
	bool subdivNearSurfaceSIDED(double x0, double y0, double z0, searchSIDE testside,
								Bpoint *nearpoint, double *neardist, bool *outsideFLAG = NULL);

	// using above function in a bisection search, find the opposing boundary involute
	//    (point on opposite side equidistant with boundpnt from a medial point along
	//     a normal from each) and compute the medial atom corresponding to these involutes
	//bool subdivMedialStuff(Bpoint *boundpnt, Bpoint *boundpnt_opp, Diatom *medialatom);

	// As above, but just compute an approxiimate medial atom based on
	//    the boundary positions P(u, v, t) and P(u, v, -t), by computing
	//    the intersections of their normals with their bisecting plane,
	//    and averaging the intersections to get the new medial position.
	//bool subdivMedialStuff2(Bpoint *boundpnt, Bpoint *boundpnt_opp, Diatom *medialatom);

	// return a Bpoint corresponding to the boundary point at (u, v, t) based on the
	//   input Diatomgrid and subdivided into the workgrid.  It'll go ahead 
	//   and compute the subdivided workgrid if that hasn't already been done.
	//      ---if false, and no current one, returns false
	//   If successfully computed point (if legal address), return true, else false
	// NOTE:  ComputeSubdivBoundaryTiles() *MUST* be called before this, so that
	//   there is a tileset present and {u, v, t} tile parameter variables have been set
	bool subdivBposition(Bpoint *Bpnt, double u, double v, double t, double w);

	// Two helper routines to give range [0, max_u] and [0, max_v] for (u, v, t) parameter
	//    space.  t is always in [-1, 1].
	double max_u(int figureId) 
	{ 
		if(ValidFigureID(figureId))
			return pListOriginal[figureId]->max_u();//newGrid[figureId]->cols - 1; }
		else
			return -1;
	}
	double max_v(int figureId) 
	{ 
		if(ValidFigureID(figureId))
			return pListOriginal[figureId]->max_v();//newGrid[figureId]->rows - 1; }
		else
			return -1;
	}

	// Specify colors for bicolor rendering
	void setColors(const float * primary, const float * secondary) {
		color1 = primary;
		color2 = secondary;
		color3[0] = (float) (secondary[0]/2.0);
		color3[1] = (float) (secondary[1]/2.0);
		color3[2] = (float) (secondary[2]/2.0);
	}

	// if subdivtileset/subdivbpoints != NULL, render surface tiles/wires/points
	void glRenderSubdivPoints();
	void glRenderSubdivWires();
	// displacement causes a sinusoidal varying displacement between boundary and
	//    medial surface, 0 = no displacement
	void glRenderSubdivTiles(double displacement = 0.0);

	//Added by CL 01/21/02.  Add displacements to boundary points
	void applyDisplacements(int numPts, double * displacements);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// New function to clear up the pointers of
	// subdivtileset, subdivtileindices and tneighbors
	void ClearBoundaryTilesPointers();
	// New function to clear up the pointers of
	// subdivbpoints and vneighbors
	void ClearPointCloudPointers();
	void ClearPointlistServerPointers()
	{
		int i;
		for(i=0; i<figureNum; i++)
			if(pListOriginal[i]!=NULL)
			{
				delete pListOriginal[i];
				pListOriginal[i]=NULL;
			}
	}

	void ComputeSubdivPointCloud(int subLevel);
	void ComputeSubdivBoundaryTiles(int subLevel);
	void ComputeFigureMapToRemove(int *numPtsToRemove, short **vertexMapToRemove, \
		int subLevel, int fId);
	void ComputeFiguresMapsToRemove(int *numPtsToRemove, short **vertexMapToRemove, \
		int subLevel);

	bool InitializeSubdivSurf(int subLevel);
	bool InitializeSubdivSurf(M3DObject *object, int subLevel = 1);

	// return a Bpoint corresponding to the boundary point at (u, v, t) based on the
	//   input Diatomgrid and subdivided into the workgrid.  It'll go ahead 
	//   and compute the subdivided workgrid if that hasn't already been done.
	//      ---if false, and no current one, returns false
	//   If successfully computed point (if legal address), return true, else false
	// NOTE:  ComputeSubdivBoundaryTiles() *MUST* be called before this, so that
	//   there is a tileset present and {u, v, t} tile parameter variables have been set
	bool subdivBPosition(Bpoint *Bpnt, double u, double v, double t, double w);
	//bool subdivBposition(Bpoint *Bpnt, double u, double v, double t);

	// bool subdivBPositionNormal(Bpoint *BPosition, Bpoint *BNormal, double u, double v, double t);
	bool WithinPolygonUVT(CCMesh *thisMesh, CCPolygon *thisPoly, double u, double v, double t);
	bool WithinPolygonUVT(int subLvl, CCPolygon *thisPoly, double u, double v, double t);
	int WithinPolygonAtSublvlUVT(CCPolygon *thisPoly, int subLvl, double u, double v, double t);
	int WithinPolyDexAtSublvlUVT(int pDex, int subLvl, double u, double v, double t);

	bool InterpolateQuad(CCVertex *vert, double u, double v, double t, double w, CCPolygon *poly, int subLvl);
	bool InterpolateVertex(CCVertex *vert, double u, CCVertex *vert1, CCVertex *vert2);
	// Two helper routines to give range [0, max_u] and [0, max_v] for (u, v, t) parameter

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void glRenderBlendedObject(int subLvl, RenderStyle renderMode);

	void glRender(int subLvl, RenderStyle renderMode);
	void glRender(int subLvl, int polyDex, RenderStyle renderMode, MyFloat *c);
	void glRender(int vNum, int fNum, Bpoint2 *vList, PindexList *fList, RenderStyle renderMode, MyFloat *c);
	void glRenderCurve(int startPDex, int endPDex, Bpoint2 *pntList, MyFloat *c);
	void glRenderSegments(int startPDex, int endPDex, Bpoint2 *pntList, MyFloat *c);

	void glRenderBlended(int subLvl, RenderStyle renderMode);
	void glRenderPoint(Bpoint2 pnt, MyFloat *c);

	int lookUpTable[300];
	void BuildLookUpTableForPDexByUVT();
	int LookUpPDexByUVT(int figureId, Bpoint2 pt);

	bool InitializeBlendedSubdivSurf(int vNum, int fNum, Bpoint2 *vList, PindexList *fList, int *vTag, int *fTag);
	bool InitializeBlendedSubdivSurf_1(int subLevel, int lvlToCalculateIntersection, \
		int vNum, int fNum, Bpoint2 *vList, PindexList *fList, int *vTag, int *fTag);
	bool InitializeBlendedSubdivSurf_New(int subLevel, int lvlToCalculateIntersection, \
		int vNum, int fNum, Bpoint2 *vList, PindexList *fList, int *vTag, int *fTag);
	//bool InitializeBlendedSubdivSurfNew(SUBDIV_LEVEL_TO_USE, vOffsetT, fOffsetT, vList, fList, vTag, fTag, pListOld);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	CCSubdivsurf* GetThisSurfPointer()
	{
		return thisSurf;
	}

	Pointlist_server2* GetOriginalPList(int dex)
	{
		if(dex>=0 && dex<=1)
			return pListOriginal[dex];
		else
			return NULL;
	}

	//bool glRender();
	void SetRenderMode(RenderStyle rM) { rMode = rM; }

	void lineWidth(int width = 1) 
	{ 
		lineDotWidth = (float) width; 
		if (thisSurf != NULL)
			thisSurf->setLineDotWidth(width);
	}

private:
	enum SubfigureAttachment_t
	{
		UNATTACHED = 0,
		PROTRUDE = 1,
		INDENT = 2
	};

	float lineDotWidth;

	// Type of attachment
	SubfigureAttachment_t * attachmentsType;

	// number of the points on the sub-figure cut curve, used to regularize the intersection curve(s)
	int numPointsOnCutCurve;
	MyFloat MINIMAL_SEGMENT_LENGTH_SQUARE;

	// level of surface to calculate the blending
	int SUBDIV_LEVEL_TO_USE;
	MyFloat UVT_UNIT;
	void DetermineParametersBasedOnSublvlToUse();

	bool ComputeBlending(int treeId = 1);
	bool ComputeBlending_temp(int treeId = 1);

	RenderStyle rMode;

	void IntersectMeshes(MyFloat uCutOff, int nTiles1, Bpoint *tile1, int nTiles2, Bpoint *tile2, \
		int *interPPair, Bpoint2 *interPList, int *polyDexList1, int *polyDexList2, int *intPNum);
	bool FindIntersectionCurveFromSegments(Bpoint2 *interPList2, int *interPPair2, int *intPNum, \
		Bpoint2 *interPList, int *interPPair, MyFloat EPSILON2);
	bool FindCurveFromSegments();

public:

};

// constructor() -- create null Pointlist_serverB
inline Pointlist_serverB::Pointlist_serverB() 
{
	rMode=NO_RENDER;

	object=NULL;
	subObject = NULL;
	figureNum=-1;
	numTrees=0;
	blendExtents = NULL;
	blendAmounts = NULL;
	attachmentsType = NULL;

#ifdef DEBUG
	cout << "Pointlist_serverB::Pointlist_serverB() called" << endl;
#endif

	figureNum=-1;
	pListOriginal=NULL;

	numsubdivpoints = 0;
	subdivbpoints = NULL;
	vneighbors = NULL;

	numsubdivtiles = 0;
	subdivtileset = NULL;
	subdivtileindices = NULL;
	tneighbors = NULL;

	thisSurf=NULL;
	subdivSurfInitialized=false;

	currentBoundaryTilesLevel=-1;
	currentPointCloudLevel=-1;

	lineDotWidth=1.0;
}

