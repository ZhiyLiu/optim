/********************************************************************************/
/*                                                                              */
/*      File    :  Pointlist_server2.H											*/
/*                                                                              */
/*      Description:  class definition for new PointCloud pointlist server,		*/
/*			which takes an Xferlist or Subdivsurf, copies the Diatomgrid, and	*/
/*			and returns points, normals, and radii of the surface near a Diatom */
/*			given an interpolation of the medial mesh to generate a dense		*/
/*			pointset, but NOT generating a smooth subdivision surface.			*/
/*																				*/
/*		NOTE:  We use a scaled, shifted cosine to generate multiplier			*/
/*			between [1, eta] for the radii on endcaps.							*/
/*                                                                              */
/*      Project :  Seurat                                                       */
/*                                                                              */
/*      Author  :  A. Thall, S. Joshi                                           */
/*                                                                              */
/*      Date    :  3. June 2000													*/
/*                                                                              */
/*      Modifications:                                                          */
/*			17. July -- added ComputeBoundaryTiles(), glRenderTiles(), and		*/
/*				tileinfo()														*/
/*			18. July -- added ComputeTilePointCloud()							*/
/*			7. Aug -- (Joshi & Thall) added (u, v, t) parameter to Bpoint and	*/
/*				relevant routines.												*/
/*			10. Aug -- added Bposition(u, v, t) providing a look-up for 		*/
/*				boundary positions												*/
/*			11. Aug -- changed gridsubdivrows=0 to rowspacing=1 for no			*/
/*				subdivision, and likewise gridsubdivcols to colspacing=1		*/
/*				Changed meshsubdivrow= 0 to meshrowspacing=1, & likewise		*/
/*			4. Dec 00 -- changed alphafun() to etafun()							*/
/*			7. Dec 00 -- also merged in some partial-rendering code from Graham */
/*				Gash's version of older Seurat in Pablo.						*/
/*			29. Jan 01 -- Added update_mesh() to modify internal Diatomgrid		*/
/*				and update Interpolfig object.									*/
/*			2. May 01 -- Added subdivtileset and numsubdivtiles, for Bpointlist */
/*				generated by the boundary of a Subdivsurf called on the			*/
/*              interpolation-subdivided workgrid.								*/
/*				Added functions ComputeSubdivBoundaryTiles()					*/
/*								ComputeSubdivPointCloud()						*/
/*                          and SubdivTileInfo()								*/
/*                          and SubdivBoundaryInfo()							*/
/*				to create and access these subdivision surface boundary lists	*/
/*				(Added subdivbpoints and subdivnumpoints for vertex lists.)		*/
/*			5. May -- added subdivtileneighbors() to return tile-indexed list	*/
/*				of neighboring tile indices (See Class Tileneighbor in			*/
/*				Subdivsurf.h, simply int array of indices)						*/
/*				Added Tileneighbors *tneighbor as class member					*/
/*				Modified ComputeSubdivBoundaryTiles to compute tneighbor list.	*/
/*			3. Aug 01 -- added subdivNearpoint() functions,						*/
/*				which return (u, v, t)  and (x, y, z) coords for the			*/
/*				nearest point on the subdivided surface (at given level of		*/
/*				interations) to an external (x0, y0, z0).						*/
/*				NOTE:  this should be able to return a vector of such values	*/
/*			8. Aug 01 -- added subdivNearSurface(), which finds the bilinearly	*/
/*				interpolated point on the nearest tile with a Phong-normal		*/
/*				nearest the point (x0, y0, z0) in angle							*/
/*          13. Aug 01 -- added num_ucoltiles, num_vrowtiles, num_t_tiles to	*/
/*				hold data on subdivision tileset needed for indexing of (u,v,t) */
/*			    values.															*/
/*			14. Aug -- added subdivBposition() to return Bpoint on the tiled	*/
/*				subdivision generated boundary corresponding to a given (u,v,t) */
/*			    Added interpolate_quad() to slice a quad of Bpoints (counter-	*/
/*				-clockwise order) into two triangles and bilerp across them,	*/
/*				chosing upper (a,d,c) if u (vertical) > v (horizontal).			*/
/*			9. Sept -- added interpolate_quad2(), and altered interface to		*/
/*				subdivNearSurface() to return boolean for success and to		*/
/*				give a Bpoint and a distance on success.						*/
/*          23. Sept -- added subdivNearSurfaceSIDED(), as above but only		*/
/*				searches tiles on top (TOP_p) or bottom (!TOP_p) tilesheet,		*/
/*				and ignores crest tiles.  This used for finding corresponding	*/
/*              involutes and medial atoms for a given surface Bposition.		*/
/*			    Added subdivMedialStuff() to return medial atom and opposing	*/
/*				boundary position corresponding to an input Bposition.			*/
/*			26. Sept -- modified subdivNearSurfaceSIDED to select using			*/
/*				the new searchSIDE enum, including the crest tiles.				*/
/*			 2. Oct -- added outsideFLAG parameter to subdivNearSurface()		*/
/*				which is set if passed a non-NULL value, else no action taken.	*/
/*			12. Nov -- added subdivvertexneighbors() to get vertex neighborlist	*/
/*					added Tileneighbor *vneighbors with vertex neighbors.		*/
/*			    Dec 01 -- modified glRenderSubdivTiles() with a displacement	*/
/*					term to perturb boundary toward medial axis.				*/
/*			23. Jan 02 -- added subdivtileindexinfo()							*/
/*                               copySubdivTileIndexInfo(),						*/
/*					 returns list of quad-tiles									*/
/*					as sets of 4 indices into bptlist of vertices returned		*/
/*                  by subdivboundaryinfo()										*/
/*				copySubdivTileInfo() was changed to return ntiles, not number   */
/*					of points in list (== ntiles*4).							*/
/*				added int *subdivtileindices list for above						*/
/*			11. Apr 02 -- updated with new Nearpoint-finding code				*/
/*			24. June 02 -- eliminated workgrid, all interpolfig code			*/
/********************************************************************************/

typedef enum { TOPSIDE, TOPCREST, BOTTOMCREST, BOTTOMSIDE } searchSIDE;
typedef std::queue<int> IntQueue;
typedef std::set<int> IntSet;


class Pointlist_server2
{
	Diatomgrid *newGrid;

	bool subdivSurfInitialized;

	// New lists for subdivsurf derived bpoints and tilesets
	Bpoint *subdivbpoints;
	int numsubdivpoints;
	Tileneighbors *vneighbors;	// neighboring vertex list

	Bpoint *subdivtileset;
	int numsubdivtiles;
	int num_ucoltiles, num_vrowtiles, num_t_tiles;
	Tileneighbors *tneighbors;	// neighboring tile list

	// the new neighboring vertex list for area calculation in Mask
	NeighborVertices *neighboringVerts;

	// as above, but indices of tileset vertices into subdivbpoints list
	int *subdivtileindices;

	double etafun(double eta, double theta, double rotangle);

	const float * color1;
	const float * color2;
	float color3[3];

	// keep track of last tile on which a nearpoint was found as initializer
	//   for next search
	PseudoSet OldnearsetA;
	PseudoSet nearset;        // set container for int value
	PseudoSet neighborset;		// Check neighbors of OldnearsetA tiles if none of them are possible
	PseudoSet neighborset2;
	PseudoSet neighborset3;

	PseudoSet OldnearsetB;	// Separate OldnearsetB for subdivNearSurfaceSIDED()

	int smoothness;		// Variability of angle between spoke vectors and surface tiles
	float lineDotWidth;	// Width of lines and dots rendered

	CCSubdivsurf* thisSurf;

	int currentBoundaryTilesLevel;
	int currentPointCloudLevel;

	// the level of the highest subdivision level that has ever been initialized
	int highestInitializedSubLevel;

public:
	// inline constructor and destructor---see below
	Pointlist_server2();
	~Pointlist_server2();

	// initialize the Pointlist_server2, passing in either an Xferlist
	//	  or an already created Subdivsurf; this creates a local newgrid
	//	  mesh{rows,cols}spacing gives number of sections per initial meshgrid
	//	  (default = 1 gives just original mesh atoms).  The first function
	//	  sets the smoothness angle from the Xferlist; with the second function,
	//	  use setSmoothness() to do this.  A default smoothness of 0 is set in
	//	  the constructor.
	void init(Xferlist *mfig1);
	void init(Subdivsurf *subfig1);
	void init(int numverts, int numfaces, Bpoint * pntlist, PindexList * faces,
		int sublvl);	// Render a surface from a list of points

	void setSmoothness(int val) { smoothness = val; }

	// Functions to change the internal Diatomgrid  with the new atom's values
	void update_mesh(XferAtom *thisatom, int Xfer_col, int Xfer_row);
	void update_mesh(Diatom *thisatom, int u_col, int v_row);

	// Compute bpointlist of subdivision surface boundary generated from initial
	//    diatomgrid interpolated to mesh{row,col}spacing and then sent to Subdivsurf
	//    for Subdivision 0 <= subdivlevel <= 6 and then output of resulting tiles
	//    to subdivtileset
	void ComputeSubdivBoundaryTiles(int subdivlevel = 0);

	// initialize bpoints[] with boundary involutes of the atoms of 
	//   the medially-subdivided mesh---these would be vertices of
	//   the boundary tiles computed by ComputeBoundaryTiles().
	// NOTE:  there is NO REDUNDANCY in this list
	void ComputeSubdivPointCloud(int subdivlevel);

	// Returns a pointer to the internal list of 8 tile numbers adjacent to the
	// specified tile number.
	void adjacencyList(int tile, Tileneighbors **adjlistptr) {
		*adjlistptr = tneighbors + tile;
	}

	// Returns a pointer to the entire, internal adjacency list computed above.  The
	// length will be 8 times the number of tiles.
	//void adjacencyinfo(int *length, short **adjlistptr);

	// returns pointer to internal list of subdivsurf generated boundary vertices
	void subdivboundaryinfo(int *numpoints, Bpoint **bptlistptr);
    // Same as above, but returns a copy, not a pointer to internal array
    void copySubdivBoundaryInfo(int * numpts, Bpoint **bptlistptr);

	// returns pointer to internal list of quad-tiles produced by Subdivsurf
	void subdivtileinfo(int *ntiles, Bpoint **bptlistptr);

	// Added by Tom, does same as above but returns a copy, not the internal
    // Also returns number of points not tiles
    void copySubdivTileInfo(int * numpts, Bpoint **bptlistptr);

	// returns list of quad-tiles as sets of 4 indices
	//    into bptlist of vertices returned by subdivboundaryinfo()
	void subdivtileindexinfo(int *ntiles, int **vertlistptr);
	// as above, but makes copy of internal list
	void copySubdivTileIndexInfo(int *ntiles, int **vertlistptr);

	// returns pointer to internal list of Tileneighbors, indexed by tilenumbers
	//    from above list.  It is an error to call this before calling 
	//    ComputeSubdivBoundaryTiles() or ComputeSubdivPointCloud()
	//    Not of much use without the tilelist, anyway.
	void subdivtileneighbors(int *ntiles, Tileneighbors **neighbors);

	// returns pointer to internal list of Vertexneighbors, indexed by vertexnumbers
	//    from above list.  It is an error to call this before calling 
	//    ComputeSubdivPointCloud() Not of much use without the vertexlist, anyway.
	void subdivvertexneighbors(int *nverts, Tileneighbors **neighbors);

	// return the new neighboring vertex list for area calculation in Mask
	void subdivNeighborVertices(int subLevel, int *nverts, NeighborVertices **_neighboringVerts);

	// return the nearpoint(s) on the surface---return value is the distance itself
	double subdivNearpoint(double x0, double y0, double z0, 
		                   DbVector3 *nearpointXYZ, DbVector3 *nearpointUVT, int *multiplicity);
	double subdivNearQuads(double x0, double y0, double z0, 
		                   DbVector3 *nearpointXYZ, DbVector3 *nearpointUVT, int *multiplicity);

	// return bool for success, and load Bpoint with surface position and neardist with distance
	//    from (x0, y0, z0) to that position.  If outside_FLAG != NULL, set true if point found
	//    to be outside object, else false
	bool subdivNearSurface(double x0, double y0, double z0, Bpoint *nearpoint, double *neardist,
		                   bool *outsideFLAG = NULL);
	// Clears Oldnearset cache used in above, reinitializes to prevent lock on old value
	//    when a new location may be closer
	void clear_cache() { OldnearsetA.clear(); }

	// as above, but only searches tiles on tilesheet selected by searchSIDE testside
	//    This used for finding corresponding involutes and medial atoms for a given 
	//    surface Bposition.
	bool subdivNearSurfaceSIDED(double x0, double y0, double z0, searchSIDE testside,
								Bpoint *nearpoint, double *neardist, bool *outsideFLAG = NULL);

	// using above function in a bisection search, find the opposing boundary involute
	//    (point on opposite side equidistant with boundpnt from a medial point along
	//     a normal from each) and compute the medial atom corresponding to these involutes
	//bool subdivMedialStuff(Bpoint *boundpnt, Bpoint *boundpnt_opp, Diatom *medialatom);

	// As above, but just compute an approxiimate medial atom based on
	//    the boundary positions P(u, v, t) and P(u, v, -t), by computing
	//    the intersections of their normals with their bisecting plane,
	//    and averaging the intersections to get the new medial position.
	//bool subdivMedialStuff2(Bpoint *boundpnt, Bpoint *boundpnt_opp, Diatom *medialatom);

	// return a Bpoint corresponding to the boundary point at (u, v, t) based on the
	//   input Diatomgrid and subdivided into the workgrid.  It'll go ahead 
	//   and compute the subdivided workgrid if that hasn't already been done.
	//      ---if false, and no current one, returns false
	//   If successfully computed point (if legal address), return true, else false
	// NOTE:  ComputeSubdivBoundaryTiles() *MUST* be called before this, so that
	//   there is a tileset present and {u, v, t} tile parameter variables have been set
	bool subdivBposition(Bpoint *Bpnt, double u, double v, double t);
	bool subdivBPosition(Bpoint *Bpnt, double u, double v, double t);
	//bool subdivBposition(Bpoint *Bpnt, double u, double v, double t);

	int subdivNearestBPosition(Bpoint *Bpnt, double u, double v, double t);


	// Two helper routines to give range [0, max_u] and [0, max_v] for (u, v, t) parameter
	//    space.  t is always in [-1, 1].
	double max_u() { return newGrid->cols - 1; }
	double max_v() { return newGrid->rows - 1; }

	// Specify colors for bicolor rendering
	void setColors(const float * primary, const float * secondary) {
		color1 = primary;
		color2 = secondary;
		color3[0] = (float) (secondary[0]/2.0);
		color3[1] = (float) (secondary[1]/2.0);
		color3[2] = (float) (secondary[2]/2.0);
	}

	// if bpoints != NULL, render surface point cloud
	void glPartialRenderSubdivPoints(double * distances, double cufoffDistance, bool complete);

	// if tileset != NULL, render wireframe surface
	void glPartialRenderSubdivWires(double * distances, double cufoffDistance, bool complete);

	// if tileset != NULL, render surface tiles
	void glPartialRenderSubdivTiles(double * distances, double cufoffDistance, bool complete);

	// if subdivtileset/subdivbpoints != NULL, render surface tiles/wires/points
	void glRenderSubdivPoints();
	void glRenderSubdivWires();

	// displacement causes a sinusoidal varying displacement between boundary and
	//    medial surface, 0 = no displacement
	void glRenderSubdivTiles(double displacement = 0.0);

	void glRenderColoredSubdivPoints(float * colors, int numColors, float min, float max);
	void glRenderColoredSubdivWires(float * colors, int numColors, float min, float max);
	void glRenderColoredSubdivTiles(float * colors, int numColors, float min, float max,
		bool outlineTiles = true, double displacement = 0.0);

	//Added by CL 01/21/02.  Add displacements to boundary points
	void applyDisplacements(int numPts, double * displacements);

	// FIXME: TODO: Need to work this out for tubes - rrs/gst/eli
	//Added for Eli to do atom regions
	bool computeLvl0VertAtomList(int numRows, int numCols, int *list);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// New function to clear up the pointers of
	// subdivtileset, subdivtileindices and tneighbors
	void ClearBoundaryTilesPointers();
	// New function to clear up the pointers of
	// subdivbpoints and vneighbors
	void ClearPointCloudPointers();

	bool InitializeSubdivSurf(int sublvl);
	//bool InitializeSubdivSurf();

	void InitializeSubdivSurf(Xferlist *xferList);

	void UpdateSubdivBoundaryTiles(int subLevel, Diatomgrid *thisGrid);
	void UpdateSubdivPointCloud(int subLevel, Diatomgrid *thisGrid);
	bool UpdateSubdivSurf(int subLevel, Diatomgrid *thisGrid);

	void UpdateSubdivBoundaryTiles(int subLevel, Xferlist *thisList);
	void UpdateSubdivPointCloud(int subLevel, Xferlist *thisList);
	bool UpdateSubdivSurf(int subLevel, Xferlist *thisList);

	// bool subdivBPositionNormal(Bpoint *BPosition, Bpoint *BNormal, double u, double v, double t);
	bool WithinPolygonUVT(CCMesh *thisMesh, CCPolygon *thisPoly, double u, double v, double t);
	bool WithinPolygonUVT(int subLvl, CCPolygon *thisPoly, double u, double v, double t);
	int WithinPolygonAtSublvlUVT(CCPolygon *thisPoly, int subLvl, double u, double v, double t);
	int WithinPolyDexAtSublvlUVT(int pDex, int subLvl, double u, double v, double t);

	bool InterpolateQuad(CCVertex *vert, double u, double v, double t, CCPolygon *poly, int subLvl);
	bool InterpolateVertex(CCVertex *vert, double u, CCVertex *vert1, CCVertex *vert2);
	// Two helper routines to give range [0, max_u] and [0, max_v] for (u, v, t) parameter

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void lineWidth(int width = 1) 
	{ 
		lineDotWidth = (float) width; 
		if (thisSurf != NULL)
			thisSurf->setLineDotWidth(width);
	}

	void glRender(int subLvl, RenderStyle renderMode);

	Mesh *thisMesh;

	int lookUpTable[300];
	void BuildLookUpTableForPDexByUVT();
	int LookUpPDexByUVT(Bpoint2 pt);

	bool subdivBPositionControlMesh(int lvl, Bpoint *Bpnt, double u, double v, double t);
	bool InterpolateQuadControlMesh(CCVertex *vert, double u, double v, double t, CCPolygon *poly, int subLvl);
	bool InterpolateVertexControlMesh(CCVertex *vert, double u, CCVertex *vert1, CCVertex *vert2);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	CCSubdivsurf* GetThisSurfPointer()
	{
		return thisSurf;
	}
};


// constructor() -- create null Pointlist_server2
inline Pointlist_server2::Pointlist_server2() 
{
	newGrid=NULL;

	numsubdivpoints = 0;
	subdivbpoints = NULL;
	vneighbors = NULL;

	numsubdivtiles = 0;
	subdivtileset = NULL;
	subdivtileindices = NULL;
	tneighbors = NULL;

	neighboringVerts = NULL;

	thisMesh=NULL;

	thisSurf=NULL;
	subdivSurfInitialized=false;

	currentBoundaryTilesLevel=-1;
	currentPointCloudLevel=-1;
	highestInitializedSubLevel=-1;
}

// destructor()
inline Pointlist_server2::~Pointlist_server2() 
{
	delete newGrid;

	ClearPointCloudPointers();
	ClearBoundaryTilesPointers();


	if (thisMesh!=NULL)
		delete thisMesh;
	if (thisSurf!=NULL)
		delete thisSurf;
}

