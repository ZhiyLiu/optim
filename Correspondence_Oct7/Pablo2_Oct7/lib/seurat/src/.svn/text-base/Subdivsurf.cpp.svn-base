/****************************************************************************/
/*																			*/
/*  	File	:  Subdivsurf.cpp											*/
/*																			*/
/*	Description:  class functions for Subdivsurf, a self-contained			*/
/*		class for creating and rendering subdivision surfaces from			*/
/*		Mfigs.																*/
/*																			*/
/*	Project :  Seurat														*/
/*																			*/
/*	Author  :  A. Thall														*/
/*																			*/
/*	Date	:  8. April 2000												*/
/*																			*/
/*	Contents:																*/
/*																			*/
/*	Modifications:  														*/
/*		27. May 00 -- added normlist, radiuslist, and parentlist			*/
/*			objects to subdivnodes/subdivRenderObjs.  Also extended			*/
/*			subdivision levels from 4 to 7 deep.							*/
/*		28. May 00 -- added create_{pointlist, normlist, radiilist}			*/
/*			to support Pointlist_server class.								*/
/*			Added create_Parentsets() routine to support Pointlist_server	*/
/*		30. May -- added support for Parentset field of Diatomgraph...these	*/
/*			are initialized once (in Pointlist_server.cpp) for the input	*/
/*			Diatomgrid, then propagate through Interpolfig and Subdivsurf.	*/
/*			HOW:  even vertices keep sets of parents unchanged.				*/
/*				  odd edge vertices take sets of 2 parents sharing edge		*/
/*				  odd face vertices take sets of 4 parents sharing face		*/
/*		31. May -- added routines to output pointregions for selected		*/
/*			diatoms from ORIGINAL generating Diatomgraph (NOT from self!)	*/
/*		10. June -- class encapsulated subdivnode so can use operator=()	*/
/*			and .setvals() to clean up code a bit.							*/
/*		4. July -- added GLrenderv1v2bTOL() to draw v1/v2/b vectors with	*/
/*			their cyan-labeled tolerance regions.							*/
/*		2. May 01 -- added Subdiv_tileinfo() to generate Bpointlist for		*/
/*			external processing.  (u, v, t) are dummy values---only pnt[],	*/
/*			norm[], and rad are set.										*/
/*			Added Subdiv_boundaryinfo() to give just the boundary vertices,	*/
/*          rather than the tile list.										*/
/*		4. May 01 -- added get_tileneighbors(), using typedefed int[8]		*/
/*          Tileneighbors as defined Subdivsurf.h							*/
/*		8. May 01 -- changed tile output order in mod_subdiv() to conform	*/
/*			with top-first, then bottom, then sides order of neighbor		*/
/*			computation list.												*/
/*		22. May 01 -- set up routines to give correct (u, v, t) values		*/
/*			for subdivision mesh.  EVEN vertices don't change, ODD FACES	*/
/*			are averaged w/ w=0.25, and ODD SIDES are averaged just over	*/
/*			the two adjacent EVEN edge vertices, not over 6-neighborhood.	*/
/*			#define NORMALIZE_UVT in header file gives all coords in [0, 1].*/
/*			else (u, v, t) in ([0, numcols - 1], [0, numrows - 1], [-1, 1].	*/
/*		5. Jun 01 -- changed to arrays of subdivmeshes and subdivrenderobjs	*/
/*			indexed [0, NUMSUBLEVELS -1].  Began changes to give limit		*/
/*			points and limit-point normals for subdivision surface.			*/
/*				  -- changed Subdiv_BoundaryInfo to actually use subdivlevel*/
/*					as input, rather than activemesh.						*/
/*		7. Jun -- simplified code with load() functions for Tileneighbors	*/
/*			and Vertexneighbors.											*/
/*			Eliminated 	int create_pointlist(double **veclistptr);			*/
/*						int create_normlist(double **veclistptr);			*/
/*						int create_radiilist(double **radiiptr); which were	*/
/*			for old PointlistServer and not used anymore.					*/
/*		24. Jun -- added inverse_limit_mesh() and compute_inverse_point()	*/
/*          to produce a perturbed sub[0] mesh according to an approximation*/
/*          of the desired limit positions.									*/
/*		9. Aug -- added compute_inverselimitpointLEVEL2() to produce a		*/
/*			second level of iteration to approach an interpolating surface.	*/
/*		13. Aug -- modified subdiv_tileinfo to give num_{u, v, t} rows to	*/
/*          to calling function for indexing purposes.  All of these functs */
/*          need to be sensibly folded back into a real subdivision boundary*/
/*          class.  Damnit, if I ever had fucking time to write code.		*/
/*		13. Aug -- BUGFIX : vertices were in clockwise (rather than counter)*/
/*			order in output tiles from modsubdiv().  Fixed this.			*/
/*		22. Aug -- fixed memory leaks in mod_subdiv()						*/
/*		12. Nov -- added get_vertexneighbors() for output of local			*/
/*			8-neighborhoods (6-neighborhoods) to Pointlist_server2.			*/
/*		19. Nov -- changed Subdiv_boundaryinfo() so that it outputs points	*/
/*			on limitmesh.  To get perturbed subdivmesh instead, comment out	*/
/*			#define below.													*/
/*		5. Dec -- BUGFIX: get_tileneighbors() was not initializing side-tiles*/
/*			at top and bottom edge											*/
/*		23. Jan 02 -- added Subdiv_tileindices(), returns tilelist			*/
/*			generated by Subdiv_tileinfo() as quads of indices into			*/
/*			list returned by Subdiv_boundaryinfo(), not explicit Bpoints	*/
/*		18. June 02 -- added true_nodeloc/true_nodenorm to subgridnode		*/
/*			added create_normalinterpolating_mesh() to create a normal-		*/
/*			interpolating level-2 mesh and substitute it for the current.	*/
/*		20. June 02 -- fixed bug in get_vneighborhoods() routine...was		*/
/*			failing to get wraparound for side meshes with numcol=2.		*/
/*		21. June 02 -- rewrote average() to use vneighbor information and	*/
/*			to use in-place subdivision rules rather than masks on parent	*/
/*			mesh.  Eliminated 8- 6- and 4- neighborhood special case		*/
/*			functions.														*/
/*      21. June 02 -- rewrote normal interpolation code to work in-place	*/
/*			on sub[2] submesh, so no copying is	necessary.  Reducing time	*/
/*			from O(Vertices) to O(involutes) = O(1).  Added DRAWNORMINTERP. */
/*		22. June -- rewrote to eliminate create_Parent{}() functions and	*/
/*			all supporting and dependent code for them.						*/
/*		24. June -- removed .plist Parentsets and all subdivision of them.	*/
/*		24. July -- added variable rotation for normal-interpolating level-2 */
/*			mesh code, so that the full theta rotation is not necessarily	*/
/*			done.  See definition of THETA_TOL below.						*/
/****************************************************************************/
#define D_SUBDIVSURF
#define D_PSEUDOSET
#define D_XFERLIST
#include "Shapedepend.h"
#include <stdio.h>
#include <math.h>
#include <float.h>

#include <stdlib.h>


#define SOR_ITERATION_COUNT	12

// Comment this out to get perturbed boundary vertices rather than limit points
//    in Subdiv_boundaryinfo()
#define OUTPUTLIMITMESH

const bool MAKE_LIMITSURFACE = true;

// This will cause normal-interpolation to be used at level-2 and higher subdivision
const bool NORMINTERP = true;

// This will draw local 1-neighborhoods around level-2 perturbed normal regions
const bool DRAWNORMINTERP = false;

// Tolerance on rotation theta = angle between involute and limit normals to rotate
//    local limit surface neighborhood.
// If theta > THETA_TOL, rotate (theta - THETA_TOL) radians toward the involute
//    normal

// What should the tolerance be on theta?  Chose 10 degrees, just arbitrarily.
//    Less than this, and no action taken.
//const double THETA_TOL_DEG = 10.0;
//const double THETA_TOL = THETA_TOL_DEG * M_PI / 180.0;
#define THETA_TOL (theta_tol_deg * M_PI / 180.0)

using namespace ThallCode;

/**
 * Takes n medial coordinates and computes their average.
 * @param	n	number of medial coordinates.
 * @param	uvt	an array of medial coordinates.
 * @param	medcoord_t	Whether slab or tube medial coordinate.
 * @return	Whether successful or not.
 */
bool Medcoord::average( int n, const Medcoord* uvt, medcoord_t type )
{
	int vi;
	double minV, maxV;
	Medcoord newuvt(0.0,0.0,0.0);

	switch(type) {
	case TubeMedCoord:
		for( vi	= 0; vi < n && uvt[vi].v>=0; vi++ ) {}
		if( vi == n ) {
			// polygon not adjacent to the end vertices
			minV	= uvt[0].v;
			maxV	= minV;
			for( vi = 1; vi < n; vi++ ) {
				if( minV > uvt[vi].v ) {
					minV = uvt[vi].v;
				}
				else if( maxV < uvt[vi].v ) {
					maxV = uvt[vi].v;
				}
			}
			for( vi = 0; vi < n; vi++ ) {
				newuvt += uvt[vi];
			}
			if( maxV - minV > 0.5 ) {
				// map all uvt.v in [0,0.5) to [1,1.5)
				for( vi = 0; vi < n; vi++ ) {
					if( uvt[vi].v >= 0.0 && uvt[vi].v < 0.5 ) {
						newuvt.v += 1.0;
					}
				}
			}
			newuvt /= n;
			if(newuvt.v >= 1.0) {
				newuvt.v -= 1.0;
			}
		}
		else {
			// polygon adjacent to the end vertices
			minV	= 1.0e+20;
			maxV	= -1.0e-20;
			unsigned int non_end_vertices	= 0;
			for( vi = 0; vi < n; vi++ ) {
				if( uvt[vi].v < 0.0) {
					continue;
				}
				non_end_vertices++;
				if( minV > uvt[vi].v ) {
					minV = uvt[vi].v;
				}
				else if( maxV < uvt[vi].v ) {
					maxV = uvt[vi].v;
				}
			}
			for( vi = 0; vi < n; vi++ ) {
				newuvt.u += uvt[vi].u;
				newuvt.t += uvt[vi].t;
				if( uvt[vi].v >= 0.0 ) {
					newuvt.v += uvt[vi].v;
				}
			}
			if( maxV - minV > 0.5 ) {
				// map all uvt.v in [0,0.5) to [1,1.5)
				for( vi = 0; vi < n; vi++ ) {
					//if(uvt[vi].v<0)
					//	continue;
					if( uvt[vi].v >= 0.0 && uvt[vi].v < 0.5 ) {
						newuvt.v += 1.0;
					}
				}
			}
			newuvt.v /= non_end_vertices;
			if(non_end_vertices == 0) {
				return false;
			}
			if(newuvt.v >= 1.0)
				newuvt.v -= 1.0;
			newuvt.u /= n;
			newuvt.t /= n;
		}
		break;
	case SlabMedCoord:
		for( vi = 0; vi < n; vi++ ) {
			newuvt += uvt[vi];
		}
		newuvt /= n;
		break;
	default:
		// unknown medial coordinate type.
		printf("%s:%d Medcoord::average(...): Unknown medial coordinate type: %d\n",
			__FILE__, __LINE__, type );
		return false;
	}
	*this	= newuvt;
	return true;
}

/**
 * Returns distance between this and another medial coord
 * in the parameter space weighting different directions equally.
 * @param	uvt		The other medial coordinate
 * @param	type	Whether slab or tube medial coordinate.
 * @return	The distance between the two coordinates.
 */
double Medcoord::distance( const Medcoord& uvt, medcoord_t type ) const
{
	double distance;
	double a;
	switch(type) {
	case TubeMedCoord:
		a	= (t-uvt.t);
		distance	= a * a;
		a	= (u-uvt.u);
		distance	+= a * a;
		a	= (v < uvt.v ) ? (uvt.v - v) : (v - uvt.v);
		if( a >= 0.5 )	a	= 1.0 - a;
		distance	+= a * a;
		distance	= sqrt(distance);
		break;
	case SlabMedCoord:
		a	= (t-uvt.t);
		distance	= a * a;
		a	= (u-uvt.u);
		distance	+= a * a;
		a	= (v-uvt.v);
		distance	+= a * a;
		distance	= sqrt(distance);
		break;
	default:
		// unknown medial coordinate type.
		printf("%s:%d Medcoord::average(...): Unknown medial coordinate type: %d\n",
			__FILE__, __LINE__, type );
		distance	= -1.0;
	}
	return distance;
}

/********************************************************************************/
/* The Subdivsurf constructor sets a pointer to the grid of the surface object	*/
/* and sets the correct renderer for grids of that type of object.				*/
/* NOTE: can pass a null pointer, but then MUST read from file before doing		*/
/*		anything else.															*/
/********************************************************************************/
Subdivsurf::Subdivsurf(Diatomgrid *thisgrid)
{
    // Assign figuregrid
	if (thisgrid != NULL)
		fig_grid = thisgrid;
	else {
		fig_grid = new Diatomgrid;
		fig_grid->rows = 0;
		fig_grid->cols = 0;
		fig_grid->dlist = NULL;
	}

    // initialize names for all objects which can be added to display list
    //   ---these will be used when modifying entries for changes to Diatom
    //   grid.
	for (int level = 0; level < NUMSUBLEVELS; level++) {
		subrast[level] = new subdivRenderObj;
		subrast[level]->initialized = false;

		sub[level].topgrid = NULL;
		sub[level].bottomgrid = NULL;
		sub[level].sidegrid = NULL;

		vneighborhoods[level].topneighbors = NULL;
		vneighborhoods[level].bottomneighbors = NULL;
		vneighborhoods[level].sideneighbors = NULL;
		vneighborhoods[level].initialized = false;
	}

	activesubmesh = NULL;
	limitsubmesh = NULL;
	tileindices = NULL;
}

/********************************************************************************/
/* ~Subdivsurf() destructor to eliminate dynamically created objects		*/
/*	(previously done by Shaperaster)  (Yeah, UGLY.)				*/
/********************************************************************************/
Subdivsurf::~Subdivsurf()
{
   // Delete this if fig_grid belongs to another dominant class
//	if (fig_grid != NULL)
//	   delete fig_grid;

	for (int level = 0; level < NUMSUBLEVELS; level++) {
		if (subrast[level]->initialized) {
			delete []subrast[level]->vertlist;
			delete []subrast[level]->normlist;
			delete []subrast[level]->radiuslist;
			delete []subrast[level]->uvtlist;
		}
		delete subrast[level];

		if (sub[level].topgrid != NULL)
			delete []sub[level].topgrid;		
		if (sub[level].bottomgrid != NULL)
			delete []sub[level].bottomgrid;		
		if (sub[level].sidegrid != NULL)
			delete []sub[level].sidegrid;

		if (vneighborhoods[level].topneighbors != NULL)
			delete []vneighborhoods[level].topneighbors;
		if (vneighborhoods[level].bottomneighbors != NULL)
			delete []vneighborhoods[level].bottomneighbors;
		if (vneighborhoods[level].sideneighbors != NULL)
			delete []vneighborhoods[level].sideneighbors;
	}

	if (limitsubmesh != NULL) {
			delete []limitsubmesh->topgrid;
			delete []limitsubmesh->bottomgrid;
			delete []limitsubmesh->sidegrid;
			delete limitsubmesh;
	}
	if (tileindices != NULL)
		delete []tileindices;
}

/********************************************************************************/
/* ModGrid() -- modify the segmentlists of the objects that already exist in	*/
/*	the displaylist of Shaperaster												*/
/********************************************************************************/
void Subdivsurf::ModGrids()
{
    // by default, none of these do a redraw
	for (int level = 0; level < NUMSUBLEVELS; level++) {
		if (subrast[level]->initialized)
			mod_subdiv(level);
	}
}

inline void loadfastvec(Fastvec fvec, DbVector3 *vec)
{
    fvec[0] = (float) vec->X();
    fvec[1] = (float) vec->Y();
    fvec[2] = (float) vec->Z();
}

/********************************************************************************/
/* GLrendermesh() -- draw the diatommesh										*/
/********************************************************************************/
void Subdivsurf::GLrendermesh()
{
	int nrows = fig_grid->rows;
	int ncols = fig_grid->cols;

	DbVector3 root, rootplusrow, rootpluscol;
	Fastvec rvec, endvec;

	glColor4d(0.0, 1.0, 0.0, 1.0);
	glBegin(GL_LINES);
	for (int col = 0; col < ncols - 1; col++) {
		for (int row = 0; row < nrows - 1; row++) {
			root = (fig_grid->dlist[fig_grid->idx(row, col)]).p_val();
			rootplusrow = (fig_grid->dlist[fig_grid->idx(row + 1, col)]).p_val();
			rootpluscol = (fig_grid->dlist[fig_grid->idx(row, col + 1)]).p_val();

			loadfastvec(rvec, &root);
			loadfastvec(endvec, &rootpluscol);
			glVertex3fv(rvec);
			glVertex3fv(endvec);

			loadfastvec(endvec, &rootplusrow);

			glVertex3fv(rvec);
			glVertex3fv(endvec);
		}
	}

	for (int col1 = 0; col1 < ncols - 1; col1++) {
		root = (fig_grid->dlist[fig_grid->idx(nrows - 1, col1)]).p_val();
		rootpluscol = (fig_grid->dlist[fig_grid->idx(nrows - 1, col1 + 1)]).p_val();

		loadfastvec(rvec, &root);
		loadfastvec(endvec, &rootpluscol);
		glVertex3fv(rvec);
		glVertex3fv(endvec);

	}

	for (int row1 = 0; row1 < nrows - 1; row1++) {
		root = (fig_grid->dlist[fig_grid->idx(row1, ncols - 1)]).p_val();
		rootpluscol = (fig_grid->dlist[fig_grid->idx(row1 + 1,ncols - 1)]).p_val();

		loadfastvec(rvec, &root);
		loadfastvec(endvec, &rootpluscol);
		glVertex3fv(rvec);
		glVertex3fv(endvec);

	}
	glEnd();
}


/********************************************************************************/
/* GLrenderv1v2b() -- draw the v1, v2 and b(for edges) vectors					*/
/********************************************************************************/
void Subdivsurf::GLrenderv1v2b()
{
	int nrows = fig_grid->rows;
	int ncols = fig_grid->cols;

	DbVector3 root, v1, v2, b, rootplusv1, rootplusv2, rootplusb;

	for (int col = 0; col < ncols; col++) {
		for (int row = 0; row < nrows; row++) {
			Diatom *dptr = &fig_grid->dlist[fig_grid->idx(row, col)];

			dptr->GLrender(RAK_atom | RAK_v1v2);
		}
	}
}

/********************************************************************************/
/* GLrenderv1v2bTOL() -- draw the v1, v2 and b(for edges) vectors and tolerance */
/********************************************************************************/
void Subdivsurf::GLrenderv1v2bTOL()
{
	int nrows = fig_grid->rows;
	int ncols = fig_grid->cols;

	DbVector3 root, v1, v2, b, rootplusv1sub, rootplusv1sup, 
		                       rootplusv2sub, rootplusv2sup,
							   rootplusbsub, rootplusbsup;
	Fastvec rvec, endvec;
	double tol_ratio, subweight, supweight;

	glBegin(GL_LINES);
	for (int col = 0; col < ncols; col++) {
		for (int row = 0; row < nrows; row++) {
			Diatom *dptr = &fig_grid->dlist[fig_grid->idx(row, col)];

			root = dptr->p_val();
			v1 = dptr->v1_val();
			v2 = dptr->v2_val();
			b = dptr->bvector();

			// get tolerance ratios for coloring end regions
			tol_ratio = dptr->rho_val();
			subweight = 1.0 - tol_ratio;
			supweight = 1.0 + tol_ratio;

			rootplusv1sub = root + v1*subweight;
			rootplusv1sup = root + v1*supweight;

			rootplusv2sub = root + v2*subweight;
			rootplusv2sup = root + v2*supweight;

			rootplusbsub = root + b*subweight;
			rootplusbsup = root + b*supweight;

			// draw segments from root to sub in red
			glColor4f(1.0, 0.0, 0.0, 1.0);
			loadfastvec(rvec, &root);
			loadfastvec(endvec, &rootplusv1sub);
			glVertex3fv(rvec);
			glVertex3fv(endvec);

			loadfastvec(endvec, &rootplusv2sub);
			glVertex3fv(rvec);
			glVertex3fv(endvec);

			if (dptr->Diatomtype() == EDGE_M || dptr->Diatomtype() == CORNER_M) {
				loadfastvec(endvec, &rootplusbsub);
				glVertex3fv(rvec);
				glVertex3fv(endvec);
			}

			// Now draw segments from sub-to-sup in cyan
			glColor4f(0.0, 1.0, 1.0, 1.0);
			loadfastvec(rvec, &rootplusv1sub);
			loadfastvec(endvec, &rootplusv1sup);
			glVertex3fv(rvec);
			glVertex3fv(endvec);

			loadfastvec(rvec, &rootplusv2sub);
			loadfastvec(endvec, &rootplusv2sup);
			glVertex3fv(rvec);
			glVertex3fv(endvec);

			if (dptr->Diatomtype() == EDGE_M || dptr->Diatomtype() == CORNER_M) {
				loadfastvec(rvec, &rootplusbsub);
				loadfastvec(endvec, &rootplusbsup);
				glVertex3fv(rvec);
				glVertex3fv(endvec);
			}
		}
	}
	glEnd();
}

/********************************************************************************/
/* GLsubdraw() -- draw the primitives from the given subdivRenderObj using the	*/
/*		requested rendering method, using OpenGL primitives						*/
/********************************************************************************/
void Subdivsurf::GLsubdraw(subdivRenderObj *subobj, RenderStyle choice)
{
	int numquads;

    numquads = subobj->nquads;
    Fastvec *vertices = subobj->vertlist;
	Fastvec *normals = subobj->normlist;
	double *radii = subobj->radiuslist;

    if (choice == WIREFRAME) {
		for (int vcnt = 0; vcnt< 4*numquads; vcnt += 4) {
			glBegin(GL_LINE_LOOP);
			glNormal3fv(normals[vcnt]);
			glVertex3fv(vertices[vcnt]);
			glNormal3fv(normals[vcnt + 1]);
			glVertex3fv(vertices[vcnt + 1]);
			glNormal3fv(normals[vcnt + 2]);
			glVertex3fv(vertices[vcnt + 2]);
			glNormal3fv(normals[vcnt + 3]);
			glVertex3fv(vertices[vcnt + 3]);	    
			glEnd();
		}		
	}
	else if (choice == FILLEDPOLY) {
		glColor4d(1.0, 1.0, 1.0, 1.0);
		glBegin(GL_QUADS);
		for (int vcnt = 0; vcnt< 4*numquads; vcnt += 4) {

			glNormal3fv(normals[vcnt]);
			glVertex3fv(vertices[vcnt]);

			glNormal3fv(normals[vcnt + 1]);
			glVertex3fv(vertices[vcnt + 1]);

			glNormal3fv(normals[vcnt + 2]);
			glVertex3fv(vertices[vcnt + 2]);

			glNormal3fv(normals[vcnt + 3]);
			glVertex3fv(vertices[vcnt + 3]);	    
		}
		glEnd();
	}
	else if (choice == VPOINTS) {
		glBegin(GL_POINTS);
		for (int vcnt1 = 0; vcnt1 < 4*numquads; vcnt1++) {
			glVertex3fv(vertices[vcnt1]);
		}
		glEnd();
	}
	// else NO_RENDER, so simply return
}

/********************************************************************************/
/* returns pointer to list of quad-tiles, each stored as 4 sequential Bpoints.  */
/*     where numtiles gives # of such 4-Bpoint tiles							*/
/*   NOTE:  Bptlistptr is created here, but control (and deletion of) passed to */
/*    calling routine															*/
/* NOTE:  to use, first call GLrendersubdiv(subdivlevel, NO_RENDER)				*/
/********************************************************************************/
void Subdivsurf::Subdiv_tileinfo(int subdivlevel, int *ntiles, Bpoint **bptlistptr,
								 int *num_ucoltiles, int *num_vrowtiles, int *num_t_tiles)
{
	subdivRenderObj *fbd;

	fbd = subrast[subdivlevel];

	int numtiles = fbd->nquads;
    Fastvec *vertices = fbd->vertlist;
	Fastvec *normals = fbd->normlist;
	double *radii = fbd->radiuslist;
	Medcoord *theseuvts = fbd->uvtlist;

	*ntiles = numtiles;
	*bptlistptr = new Bpoint[numtiles*4];

	for (int vnum = 0; vnum < numtiles*4; vnum++) {
		(*bptlistptr)[vnum].pnt[0] = (double) vertices[vnum][0];
		(*bptlistptr)[vnum].pnt[1] = (double) vertices[vnum][1];
		(*bptlistptr)[vnum].pnt[2] = (double) vertices[vnum][2];
		(*bptlistptr)[vnum].norm[0] = (double) normals[vnum][0];
		(*bptlistptr)[vnum].norm[1] = (double) normals[vnum][1];
		(*bptlistptr)[vnum].norm[2] = (double) normals[vnum][2];
		(*bptlistptr)[vnum].rad = radii[vnum];
		(*bptlistptr)[vnum].u = theseuvts[vnum].u;
		(*bptlistptr)[vnum].v = theseuvts[vnum].v;
		(*bptlistptr)[vnum].t = theseuvts[vnum].t;
	}

	// Now, get tileinfo
	subdivgrid *submesh = &sub[subdivlevel];

	*num_vrowtiles = submesh->subnumrows - 1;
    *num_ucoltiles = submesh->subnumcols - 1;
    *num_t_tiles = submesh->sidenumcols - 1;

}

// returns tilelist generated by Subdiv_tileinfo() as quads of indices into
//    list returned by Subdiv_boundaryinfo(), rather than explicit Bpoints
void Subdivsurf::Subdiv_tileindices(int subdivlevel, int **subdivtileindices)
{
	subdivRenderObj *fbd = subrast[subdivlevel];

	int npoints = fbd->nquads * 4;

	if (tileindices == NULL)
		*subdivtileindices = NULL;
	else {
		*subdivtileindices = new int[npoints];

		for (int i = 0; i < npoints; i++)
		    (*subdivtileindices)[i] = tileindices[i];
	}
}

/********************************************************************************/
/* returns pointer to  list of vertices, each stored as a Bpoint.				*/
/*           where npoints gives # of bpoints on boundary.						*/
/*   NOTE:  Bptlistptr is created here, but control (and deletion of) passed to */
/*    calling routine															*/
/* NOTE:  to use, first call GLrendersubdiv(subdivlevel, NO_RENDER)				*/
/********************************************************************************/
void Subdivsurf::Subdiv_boundaryinfo(int /*subdivlevel*/, int *npoints, Bpoint **bptlistptr)
{
	int numrows, numcols, numsiderows, numsidecols, lengthedge;

#ifdef OUTPUTLIMITMESH
	subdivgrid *submesh = limitsubmesh; 
#else
	subdivgrid *submesh = &sub[subdivlevel];
#endif

	// if uninitialized level, return 0 points and null pointer
	if (submesh->topgrid == NULL) {
		*npoints = 0;
		*bptlistptr = NULL;
		return;
	}

	numrows = submesh->subnumrows;
    numcols = submesh->subnumcols;
    numsiderows = submesh->sidenumrows;
    numsidecols = submesh->sidenumcols;
	lengthedge = submesh->edgelength;

	// number of points is top & bottom grids + sidegrid minus top and bottom edge,
	//   which were already listed in top & bottom grids
	int numpoints = 2*numrows*numcols + (numsiderows*numsidecols - 2*lengthedge);

	*npoints = numpoints;
	*bptlistptr = new Bpoint[numpoints];

	int meshindex, col, row;

	int vnum = 0;
	subgridnode *tempnode;
	for (col = 0; col < numcols; col++) {
		for (row = 0; row < numrows; row++) {
			meshindex = col*numrows + row;
			tempnode = &submesh->topgrid[meshindex];

			(*bptlistptr)[vnum].pnt[0] = tempnode->nodeloc.X();
			(*bptlistptr)[vnum].pnt[1] = tempnode->nodeloc.Y();
			(*bptlistptr)[vnum].pnt[2] = tempnode->nodeloc.Z();
			(*bptlistptr)[vnum].norm[0] = tempnode->nodenorm.X();
			(*bptlistptr)[vnum].norm[1] = tempnode->nodenorm.Y();
			(*bptlistptr)[vnum].norm[2] = tempnode->nodenorm.Z();
			(*bptlistptr)[vnum].rad = tempnode->noderadius;
			(*bptlistptr)[vnum].u = tempnode->uvt.u;
			(*bptlistptr)[vnum].v = tempnode->uvt.v;
			(*bptlistptr)[vnum].t = tempnode->uvt.t;
			vnum++;
		}
	}
	for (col = 0; col < numcols; col++) {
		for (row = 0; row < numrows; row++) {
			meshindex = col*numrows + row;
			tempnode = &submesh->bottomgrid[meshindex];

			(*bptlistptr)[vnum].pnt[0] = tempnode->nodeloc.X();
			(*bptlistptr)[vnum].pnt[1] = tempnode->nodeloc.Y();
			(*bptlistptr)[vnum].pnt[2] = tempnode->nodeloc.Z();
			(*bptlistptr)[vnum].norm[0] = tempnode->nodenorm.X();
			(*bptlistptr)[vnum].norm[1] = tempnode->nodenorm.Y();
			(*bptlistptr)[vnum].norm[2] = tempnode->nodenorm.Z();
			(*bptlistptr)[vnum].rad = tempnode->noderadius;
			(*bptlistptr)[vnum].u = tempnode->uvt.u;
			(*bptlistptr)[vnum].v = tempnode->uvt.v;
			(*bptlistptr)[vnum].t = tempnode->uvt.t;
			vnum++;
		}
	}

	// count from point (lengthedge) to (numsidepoints - lengthedge)
	int numsidepoints = numsiderows*numsidecols;
	int maxsidepoint = numsidepoints - lengthedge;

	for (int sideindex = lengthedge; sideindex < maxsidepoint; sideindex++) {

		tempnode = &submesh->sidegrid[sideindex];

			(*bptlistptr)[vnum].pnt[0] = tempnode->nodeloc.X();
			(*bptlistptr)[vnum].pnt[1] = tempnode->nodeloc.Y();
			(*bptlistptr)[vnum].pnt[2] = tempnode->nodeloc.Z();
			(*bptlistptr)[vnum].norm[0] = tempnode->nodenorm.X();
			(*bptlistptr)[vnum].norm[1] = tempnode->nodenorm.Y();
			(*bptlistptr)[vnum].norm[2] = tempnode->nodenorm.Z();
			(*bptlistptr)[vnum].rad = tempnode->noderadius;
			(*bptlistptr)[vnum].u = tempnode->uvt.u;
			(*bptlistptr)[vnum].v = tempnode->uvt.v;
			(*bptlistptr)[vnum].t = tempnode->uvt.t;
			vnum++;
	}

	if (vnum != numpoints) {
		fprintf(stderr, "ERROR:  in Subdivsurf::Subdiv_boundaryinfo:  vnum != numpoints\n");
		exit(0);
	}
}

/********************************************************************************/
/* subdiv_weightedsum() do a += of the addend to the sum, component-wise		*/
/********************************************************************************/
static void subdiv_weightedsum(subgridnode *sum, subgridnode *addend, double weight)
{
    sum->nodeloc += addend->nodeloc * weight;
	sum->nodenorm += addend->nodenorm * weight;
	sum->noderadius += addend->noderadius * weight;
}

static void subdiv_weightedsumCOORDS(subgridnode *sum, subgridnode *addend, double weight)
{
    sum->uvt.u += addend->uvt.u * weight;
	sum->uvt.v += addend->uvt.v * weight;
	sum->uvt.t += addend->uvt.t * weight;
}

/********************************************************************************/
/* subdiv_weightedprod() do a *= of the weight to the prod			*/
/********************************************************************************/
static void subdiv_weightedprod(subgridnode *prod, double weight)
{
    prod->nodeloc *= weight;
	prod->nodenorm *= weight;
	prod->noderadius *= weight;
}

static void subdiv_weightedprodCOORDS(subgridnode *prod, double weight)
{
    prod->uvt.u *= weight;
	prod->uvt.v *= weight;
	prod->uvt.t *= weight;
}

/********************************************************************************/
/* Subdivsurf::fillsubmesh0() -- loads level = 0 mesh from input Diatomgrid,	*/
/*   and assignes values for texture coordinates.								*/
/********************************************************************************/
void Subdivsurf::fillsubmesh0()
{
    int numcols, numrows;

    numcols = fig_grid->cols;
    numrows = fig_grid->rows;

    Diatom *atom = fig_grid->dlist;
    Diatom workatom;

    DbVector3 p, v1, v2, b, v1pnt, v2pnt, bpnt;
    double radius;

	double uval, vval, tvalT, tvalB, tvalE;

    // Now, Fill in top and bottom grids
    int trow, tcol, ndex;
    for (tcol = 0; tcol < numcols; tcol++) {
        for (trow = 0; trow < numrows; trow++) {

	        ndex = tcol*numrows + trow;
            workatom = atom[ndex];

	        p = workatom.p_val();
	        v1 = workatom.v1_val();
	        v2 = workatom.v2_val();
	        radius = workatom.r_val();
	        v1pnt = p + v1;
	        v2pnt = p + v2;
			uval = (double) tcol;
			vval = (double) trow;
			tvalT = 1.0;
			tvalB = -1.0;

#ifdef NORMALIZE_UVT
			uval /= (double) (numcols - 1);
			vval /= (double) (numrows - 1);
			tvalT = 1.0;
			tvalE = 0.5;
			tvalB = 0.0;
#endif
		    // set computed values
			sub[0].topgrid[ndex].setvals(v1pnt, v1.normalize(), radius, uval, vval, tvalT);
			sub[0].bottomgrid[ndex].setvals(v2pnt, v2.normalize(), radius, uval, vval, tvalB);

			involuteset_top[0].insert(ndex);
			involuteset_bottom[0].insert(ndex);
			sub[0].topgrid[ndex].true_nodeloc = v1pnt;
			sub[0].topgrid[ndex].true_nodenorm = v1.normalize();
			sub[0].bottomgrid[ndex].true_nodeloc = v2pnt;
			sub[0].bottomgrid[ndex].true_nodenorm = v2.normalize();
		}
	}
    // Now fill in side grid
    int meshindex = 0;
    for (trow = 0; trow < numrows; trow++) {
        // col == 0
        ndex = trow;

        workatom = atom[ndex];

	    p = workatom.p_val();
	    v1 = workatom.v1_val();
	    v2 = workatom.v2_val();
	    b = workatom.bvector();
	    radius = workatom.r_val();
	    v1pnt = p + v1;
	    v2pnt = p + v2;
	    bpnt = p + b;
		uval = 0.0; // column
		vval = (double) trow; // row
		tvalT = 1.0;
		tvalE = 0.0;
		tvalB = -1.0;

#ifdef NORMALIZE_UVT
		uval /= (double) (numcols - 1);
		vval /= (double) (numrows - 1);
		tvalT = 1.0;
		tvalE = 0.5;
		tvalB = 0.0;
#endif
	    // set computed values
 	    sub[0].sidegrid[meshindex].setvals(v1pnt, v1.normalize(), radius, uval, vval, tvalT);

		sub[0].sidegrid[meshindex + sub[0].edgelength].setvals(bpnt, b.normalize(), radius*workatom.eta_val(),
														       uval, vval, tvalE);

		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].setvals(v2pnt, v2.normalize(), radius,
															     uval, vval, tvalB);

		involuteset_side[0].insert(meshindex);
		involuteset_side[0].insert(meshindex + sub[0].edgelength);
		involuteset_side[0].insert(meshindex + 2*sub[0].edgelength);
		sub[0].sidegrid[meshindex].true_nodeloc = v1pnt;
		sub[0].sidegrid[meshindex].true_nodenorm = v1.normalize();
		sub[0].sidegrid[meshindex + sub[0].edgelength].true_nodeloc = bpnt;
		sub[0].sidegrid[meshindex + sub[0].edgelength].true_nodenorm = b.normalize();
		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].true_nodeloc = v2pnt;
		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].true_nodenorm = v2.normalize();

	    meshindex++;
    }
    for (tcol = 1; tcol < numcols; tcol++) {
        // trow == numrows - 1
        ndex = tcol*numrows + numrows - 1;
        workatom = atom[ndex];

	    p = workatom.p_val();
	    v1 = workatom.v1_val();
	    v2 = workatom.v2_val();
	    b = workatom.bvector();
	    radius = workatom.r_val();
	    v1pnt = p + v1;
	    v2pnt = p + v2;
	    bpnt = p + b;
		uval = (double) tcol; // column
		vval = (double) (numrows - 1); // row
		tvalT = 1.0;
		tvalE = 0.0;
		tvalB = -1.0;

#ifdef NORMALIZE_UVT
		uval /= (double) (numcols - 1);
		vval /= (double) (numrows - 1);
		tvalT = 0.0;
		tvalE = 0.5;
		tvalB = 1.0;
#endif
	    // set computed values
 	    sub[0].sidegrid[meshindex].setvals(v1pnt, v1.normalize(), radius, uval, vval, tvalT);

		sub[0].sidegrid[meshindex + sub[0].edgelength].setvals(bpnt, b.normalize(), radius*workatom.eta_val(),
														       uval, vval, tvalE);

		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].setvals(v2pnt, v2.normalize(), radius,
															     uval, vval, tvalB);

		involuteset_side[0].insert(meshindex);
		involuteset_side[0].insert(meshindex + sub[0].edgelength);
		involuteset_side[0].insert(meshindex + 2*sub[0].edgelength);
		sub[0].sidegrid[meshindex].true_nodeloc = v1pnt;
		sub[0].sidegrid[meshindex].true_nodenorm = v1.normalize();
		sub[0].sidegrid[meshindex + sub[0].edgelength].true_nodeloc = bpnt;
		sub[0].sidegrid[meshindex + sub[0].edgelength].true_nodenorm = b.normalize();
		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].true_nodeloc = v2pnt;
		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].true_nodenorm = v2.normalize();
	    meshindex++;
    }

    for (trow = numrows - 2; trow >= 0; trow--) {
        // col == numcols - 1;
        ndex = (numcols - 1)*numrows + trow;
        workatom = atom[ndex];

	    p = workatom.p_val();
	    v1 = workatom.v1_val();
	    v2 = workatom.v2_val();
	    b = workatom.bvector();
	    radius = workatom.r_val();
	    v1pnt = p + v1;
	    v2pnt = p + v2;
	    bpnt = p + b;
		uval = (double) (numcols - 1); // column
		vval = (double) trow; // row
		tvalT = 1.0;
		tvalE = 0.0;
		tvalB = -1.0;

#ifdef NORMALIZE_UVT
		uval /= (double) (numcols - 1);
		vval /= (double) (numrows - 1);
		tvalT = 0.0;
		tvalE = 0.5;
		tvalB = 1.0;
#endif
	    // set computed values
	    sub[0].sidegrid[meshindex].setvals(v1pnt, v1.normalize(), radius, uval, vval, tvalT);

		sub[0].sidegrid[meshindex + sub[0].edgelength].setvals(bpnt, b.normalize(), radius*workatom.eta_val(),
														       uval, vval, tvalE);

		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].setvals(v2pnt, v2.normalize(), radius,
														 	     uval, vval, tvalB);

		involuteset_side[0].insert(meshindex);
		involuteset_side[0].insert(meshindex + sub[0].edgelength);
		involuteset_side[0].insert(meshindex + 2*sub[0].edgelength);
		sub[0].sidegrid[meshindex].true_nodeloc = v1pnt;
		sub[0].sidegrid[meshindex].true_nodenorm = v1.normalize();
		sub[0].sidegrid[meshindex + sub[0].edgelength].true_nodeloc = bpnt;
		sub[0].sidegrid[meshindex + sub[0].edgelength].true_nodenorm = b.normalize();
		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].true_nodeloc = v2pnt;
		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].true_nodenorm = v2.normalize();

	    meshindex++;
    }
    for (tcol = numcols - 2; tcol > 0; tcol--) {
        // trow == 0
        ndex = tcol*numrows;
        workatom = atom[ndex];

	    p = workatom.p_val();
	    v1 = workatom.v1_val();
	    v2 = workatom.v2_val();
	    b = workatom.bvector();
	    radius = workatom.r_val();
	    v1pnt = p + v1;
	    v2pnt = p + v2;
	    bpnt = p + b;
		uval = (double) tcol; // column
		vval = 0.0; // row
		tvalT = 1.0;
		tvalE = 0.0;
		tvalB = -1.0;

#ifdef NORMALIZE_UVT
		uval /= (double) (numcols - 1);
		vval /= (double) (numrows - 1);
		tvalT = 0.0;
		tvalE = 0.5;
		tvalB = 1.0;
#endif
	    // set computed values
		sub[0].sidegrid[meshindex].setvals(v1pnt, v1.normalize(), radius, uval, vval, tvalT);

		sub[0].sidegrid[meshindex + sub[0].edgelength].setvals(bpnt, b.normalize(), radius*workatom.eta_val(),
														       uval, vval, tvalE);

		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].setvals(v2pnt, v2.normalize(), radius,
															     uval, vval, tvalB);

		involuteset_side[0].insert(meshindex);
		involuteset_side[0].insert(meshindex + sub[0].edgelength);
		involuteset_side[0].insert(meshindex + 2*sub[0].edgelength);
		sub[0].sidegrid[meshindex].true_nodeloc = v1pnt;
		sub[0].sidegrid[meshindex].true_nodenorm = v1.normalize();
		sub[0].sidegrid[meshindex + sub[0].edgelength].true_nodeloc = bpnt;
		sub[0].sidegrid[meshindex + sub[0].edgelength].true_nodenorm = b.normalize();
		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].true_nodeloc = v2pnt;
		sub[0].sidegrid[meshindex + 2*sub[0].edgelength].true_nodenorm = v2.normalize();

	    meshindex++;
    }
}

/****************************************************************************************/
/* Glrendersubdiv() -- enter data into subdivRenderObj if necessary and display using	*/
/*		using OpenGL drawing commands.  To be called within an Fl_Gl_Window				*/
/*		draw() function																	*/
/****************************************************************************************/
void Subdivsurf::GLrendersubdiv(int meshchoice, RenderStyle choice)
{
	std::cout << meshchoice << std::endl;
    int numcols, numrows;
    int numtopbottomquads;
    int numsidequads;

    subdivRenderObj *fbd;

	fbd = subrast[meshchoice];

    // if displaylists already created, simply call GLsubdraw(n)
    //   of thisraster
    if (fbd->initialized) {
        GLsubdraw(fbd, choice);
        return;
    }
    // ELSE recursively initialize previous levels as necessary and then this one
	if (meshchoice > 0) {
		if (subrast[meshchoice - 1]->initialized == false)
			GLrendersubdiv(meshchoice - 1, NO_RENDER);
	}
	// qiong working 12302002
    // initial grids if NULL, else just fill in new values
	if (meshchoice == 0) {
		if (sub[0].topgrid == NULL) {
			numcols = fig_grid->cols;
			numrows = fig_grid->rows;
			sub[0].subnumrows = numrows;
			sub[0].subnumcols = numcols;
			sub[0].edgelength = 2*numrows + 2*numcols - 4;
			sub[0].sidenumrows = sub[0].edgelength;
			sub[0].sidenumcols = 3;

			sub[0].topgrid = new subgridnode[numrows*numcols];
			sub[0].bottomgrid = new subgridnode[numrows*numcols];
			sub[0].sidegrid = new subgridnode[3 * sub[0].edgelength];

			numtopbottomquads = 2*(sub[0].subnumrows - 1)*(sub[0].subnumcols - 1);
			numsidequads = 2*(sub[0].edgelength);

			involuteset_top[0].init(numcols*numrows);
			involuteset_bottom[0].init(numcols*numrows);
			involuteset_side[0].init(3*(2*numcols + 2*numrows - 4));
		}
	}
	else {	
		if (sub[meshchoice].topgrid == NULL) {
			numcols = sub[meshchoice - 1].subnumcols;
			numrows = sub[meshchoice - 1].subnumrows;
			sub[meshchoice].subnumrows = 2*numrows - 1;
			sub[meshchoice].subnumcols = 2*numcols - 1;
			sub[meshchoice].edgelength = 2*sub[meshchoice - 1].edgelength;
			sub[meshchoice].sidenumrows = sub[meshchoice].edgelength;
			sub[meshchoice].sidenumcols = 2*sub[meshchoice - 1].sidenumcols - 1;

			sub[meshchoice].topgrid = new subgridnode[sub[meshchoice].subnumrows*sub[meshchoice].subnumcols];
			sub[meshchoice].bottomgrid = new subgridnode[sub[meshchoice].subnumrows*sub[meshchoice].subnumcols];
			sub[meshchoice].sidegrid = new subgridnode[sub[meshchoice].sidenumrows*sub[meshchoice].sidenumcols];

			numtopbottomquads = 2*(sub[meshchoice].subnumrows - 1)*(sub[meshchoice].subnumcols - 1);
			numsidequads = sub[meshchoice].sidenumrows*(sub[meshchoice].sidenumcols - 1);

			involuteset_top[meshchoice].init(sub[meshchoice].subnumrows*sub[meshchoice].subnumcols);
			involuteset_bottom[meshchoice].init(sub[meshchoice].subnumrows*sub[meshchoice].subnumcols);
			involuteset_side[meshchoice].init(sub[meshchoice].sidenumrows*sub[meshchoice].sidenumcols);
		}
	}

	// NEW CODE---if nearvertices not initialized already for a mesh of this level, do so now
	if (!(vneighborhoods[meshchoice].initialized))
		get_vneighborhoods(meshchoice);

    fbd->nquads = numtopbottomquads + numsidequads;
    int nrendverts = 4*fbd->nquads;

    fbd->vertlist = new Fastvec[nrendverts];
	fbd->normlist = new Fastvec[nrendverts];
	fbd->radiuslist = new double[nrendverts];
	fbd->uvtlist = new Medcoord[nrendverts];

    // mod_subdiv calls fillsubmesh0() and then creates displaylist
    mod_subdiv(meshchoice);
    fbd->initialized = true;

	GLsubdraw(fbd, choice);
}

void inline load_subdivrenderobj(subdivRenderObj *robj, int rdex, subgridnode *sdnode)
{
	loadfastvec(robj->vertlist[rdex], &(sdnode->nodeloc));
	loadfastvec(robj->normlist[rdex], &(sdnode->nodenorm));
	robj->radiuslist[rdex] = sdnode->noderadius;
	robj->uvtlist[rdex].u = sdnode->uvt.u;
	robj->uvtlist[rdex].v = sdnode->uvt.v;
	robj->uvtlist[rdex].t = sdnode->uvt.t;
}

/********************************************************************************/
/* mod_subdiv() -- enter data into already existing subdivRenderObj		*/
/********************************************************************************/
void Subdivsurf::mod_subdiv(int meshchoice)
{
    int numrows, numcols, numsiderows, numsidecols;
    subdivRenderObj *fbd;

    subdivgrid *submesh, *invmesh;
	// qiong 12302002 working
	if (meshchoice == 0) {

		fillsubmesh0();
		submesh = &sub[0];

		// NEW CODE:  This creates perturbed initializing mesh from sub[0]
		invmesh = inverse_limit_mesh(meshchoice);
		// copy invmesh to sub[0]

		int nrows = submesh->subnumrows;
		int ncols = submesh->subnumcols;
		int nsrows = submesh->sidenumrows;
		int nscols = submesh->sidenumcols;

		for (int i = 0; i < nrows*ncols; i++) {
			sub[0].topgrid[i] = invmesh->topgrid[i];
		    sub[0].bottomgrid[i] = invmesh->bottomgrid[i];
		}
		for (int i2 = 0; i2 < nsrows*nscols; i2++) {
			sub[0].sidegrid[i2] = invmesh->sidegrid[i2];
		}

		delete []invmesh->topgrid;
		delete []invmesh->bottomgrid;
		delete []invmesh->sidegrid;
		delete invmesh;
        ///////////////END NEW CODE

		fbd = subrast[0];
	}
	else
	{
		// Splitting adds even vertex values of parents to new mesh
		split(meshchoice);
		// Averaging takes this mesh and computes new odd-face and odd-edge vertices,
		//    then computes new even vertices
		averaging(meshchoice);
		submesh = &sub[meshchoice];
		fbd = subrast[meshchoice];
	}

    numrows = submesh->subnumrows;
    numcols = submesh->subnumcols;
    numsiderows = submesh->sidenumrows;
    numsidecols = submesh->sidenumcols;

	if (meshchoice == 2) {
		// Adjust sub[2] mesh to interpolate normals
		if (NORMINTERP)
			create_normalinterpolating_mesh();
	}

	if (MAKE_LIMITSURFACE) {
		if (limitsubmesh != NULL) {
			delete []limitsubmesh->topgrid;
			delete []limitsubmesh->bottomgrid;
			delete []limitsubmesh->sidegrid;
			delete limitsubmesh;
		}
		limitsubmesh = create_limit_mesh(meshchoice);
		submesh = limitsubmesh;
	}

	// store tile indices for each tile...
	//    topindices = vertXdex;
	//    bottomindices = vertXdex + numcols*numrows = vertXdex + B;
	//    sideindices = vertXdex + 2*B, and will be post-processed,
	//       due to overlap with top and bottom edges
	if (tileindices != NULL)
		delete []tileindices;
	tileindices = new int[fbd->nquads * 4];
	int B = numrows*numcols;
	int C = 2*B;

    // First, process front and back faces
    int trow, tcol;
    int vert1dex, vert2dex, vert3dex, vert4dex;

    int ndex = 0;
    for (tcol = 0; tcol < numcols - 1; tcol++) {
		for (trow = 0; trow < numrows - 1; trow++) {
			// do top quad first
			//   vertex 1
			vert1dex = tcol*numrows + trow;
			tileindices[ndex] = vert1dex;
			load_subdivrenderobj(fbd, ndex, &(submesh->topgrid[vert1dex]));
			ndex++;

			//   vertex 4
			vert4dex = tcol*numrows + trow + 1;
			tileindices[ndex] = vert4dex;
			load_subdivrenderobj(fbd, ndex, &(submesh->topgrid[vert4dex]));
			ndex++;

			//   vertex 3
			vert3dex = (tcol+1)*numrows + trow + 1;
			tileindices[ndex] = vert3dex;
			load_subdivrenderobj(fbd, ndex, &(submesh->topgrid[vert3dex]));
			ndex++;

			//   vertex 2
			vert2dex = (tcol+1)*numrows + trow;
			tileindices[ndex] = vert2dex;
			load_subdivrenderobj(fbd, ndex, &(submesh->topgrid[vert2dex]));
			ndex++;
		}
	}
	for (tcol = 0; tcol < numcols - 1; tcol++) {
		for (trow = 0; trow < numrows - 1; trow++) {
			// do bottom quad
			//   vertex 1
			vert1dex = tcol*numrows + trow;
			tileindices[ndex] = vert1dex + B;
			load_subdivrenderobj(fbd, ndex, &(submesh->bottomgrid[vert1dex]));
			ndex++;	

			//   vertex 2
			vert2dex = (tcol+1)*numrows + trow;
			tileindices[ndex] = vert2dex + B;
			load_subdivrenderobj(fbd, ndex, &(submesh->bottomgrid[vert2dex]));
			ndex++;	

			//   vertex 3
			vert3dex = (tcol+1)*numrows + trow + 1;
			tileindices[ndex] = vert3dex + B;
			load_subdivrenderobj(fbd, ndex, &(submesh->bottomgrid[vert3dex]));
			ndex++;	

			//   vertex 4
			vert4dex = tcol*numrows + trow + 1;
			tileindices[ndex] = vert4dex + B;
			load_subdivrenderobj(fbd, ndex, &(submesh->bottomgrid[vert4dex]));
			ndex++;
        }
    }

    // Now do sides
    for (tcol = 0; tcol < numsidecols - 1; tcol++) {
		for (trow = 0; trow < numsiderows; trow++){
			//   vertex 1
			vert1dex = tcol*numsiderows + trow;
			tileindices[ndex] = vert1dex + C;
			load_subdivrenderobj(fbd, ndex, &(submesh->sidegrid[vert1dex]));
			ndex++;

			//   vertex 4
			vert4dex = (tcol + 1)*numsiderows + trow;
			tileindices[ndex] = vert4dex + C;
			load_subdivrenderobj(fbd, ndex, &(submesh->sidegrid[vert4dex]));
			ndex++;

			// if on last row, wraparound to row 0
			int rowdex = (trow == numsiderows - 1 ? 0 : trow + 1);

			//   vertex 3
			vert3dex = (tcol + 1)*numsiderows + rowdex;
			tileindices[ndex] = vert3dex + C;
			load_subdivrenderobj(fbd, ndex, &(submesh->sidegrid[vert3dex]));
			ndex++;

			//   vertex 2
			vert2dex = tcol*numsiderows + rowdex;
			tileindices[ndex] = vert2dex + C;
			load_subdivrenderobj(fbd, ndex, &(submesh->sidegrid[vert2dex]));
			ndex++;
		}
    }

	fix_side_edges(tileindices, fbd->nquads, numrows, numcols, numsidecols, numsiderows);

	activesubmesh = submesh;
}

/********************************************************************************/
/* fix_side_edges() -- search side_tile indices, replacing any index			*/
/*    to the top or bottom edge of the side with the associated top or bottom	*/
/*    index.																	*/
/********************************************************************************/
void Subdivsurf::fix_side_edges(int *indexlist, int ntiles, int nrows, int ncols, int nscols, int nsrows)
{
	int B = nrows*ncols;
	int C = 2*B;   // start of first side column of vertices (columns run the long way)
	int E = nsrows;		// edgelength

	// Calculate indices to be altered (firstcol get assigned to top, last to bottom)
	//    all others get subtracted by E, to eliminate top edge that doesn't exist.)
	int firstcolbegin = C;
	int firstcolend = C + E - 1;

	int lastcolbegin = C + (nscols - 1)*E;
	int lastcolend = C + nscols*E - 1;

	//  calculate list positions to have indices altered
	int nindices = ntiles*4;
	int first_side_tile = 2*(nrows - 1)*(ncols - 1);
	int first_side_index = 4*first_side_tile;

	int rowdex, coldex;
	for (int dex = first_side_index; dex < nindices; dex++) {

		int ival = indexlist[dex];

		if ((ival > firstcolend) && (ival < lastcolbegin))

			// not on top or bottom edge, so just subtract E
			indexlist[dex] -= E;

		else if (ival <= firstcolend) {
			// Four cases for top edge, depending on which edge it's on
			ival -= C;		//zero the row

			if (ival < nrows) { // col == 0 edge
				rowdex = ival;
				coldex = 0;
				indexlist[dex] = rowdex;
			}
			else if (ival < nrows + ncols - 1) {  // row == (nrows - 1) edge
				rowdex = nrows - 1;
				coldex = ival - (nrows - 1);
				indexlist[dex] = coldex*nrows + rowdex;
			}
			else if (ival < 2*nrows + ncols - 2) { // col == (ncols - 1) edge
				rowdex = (nrows - 1) - (ival - (nrows - 1) - (ncols - 1));
				coldex = (ncols - 1);
				indexlist[dex] = coldex*nrows + rowdex;
			}
			else {	// row == 0 edge
				rowdex = 0;
				coldex = (ncols - 1) - (ival - 2*(nrows - 1) - (ncols - 1));
				indexlist[dex] = coldex*nrows;
			}
		}
		else {	// Four cases for bottom edge, same as for top, but add B
			ival -= C + (nscols - 1)*E;		// zero the row

			if (ival < nrows) { // col == 0 edge
				rowdex = ival;
				coldex = 0;
				indexlist[dex] = B + rowdex;
			}
			else if (ival < nrows + ncols - 1) {  // row == (nrows - 1) edge
				rowdex = nrows - 1;
				coldex = ival - (nrows - 1);
				indexlist[dex] = B + coldex*nrows + rowdex;
			}
			else if (ival < 2*nrows + ncols - 2) { // col == (ncols - 1) edge
				rowdex = (nrows - 1) - (ival - (nrows - 1) - (ncols - 1));
				coldex = (ncols - 1);
				indexlist[dex] = B + coldex*nrows + rowdex;
			}
			else {	// row == 0 edge
				rowdex = 0;
				coldex = (ncols - 1) - (ival - 2*(nrows - 1) - (ncols - 1));
				indexlist[dex] = B + coldex*nrows;
			}
		}
	}
}

/********************************************************************************/
/* split() -- does the splitting from (meshlevel - 1) 							*/
/*    to get (meshlevel), using Catmull-Clark rules for regular quadmeshes.		*/
/********************************************************************************/
void Subdivsurf::split(int meshlevel)
{
    int numrows_parent, numcols_parent, numsiderows_parent, numsidecols_parent;
    int numrows, numcols, numsiderows, numsidecols;

    subdivgrid *submesh, *submeshparent;
	submesh = &sub[meshlevel];
	submeshparent = &sub[meshlevel - 1];

    numrows = submesh->subnumrows;
    numcols = submesh->subnumcols;
    numsiderows = submesh->sidenumrows;
    numsidecols = submesh->sidenumcols;
    numrows_parent = submeshparent->subnumrows;
    numcols_parent = submeshparent->subnumcols;
    numsiderows_parent = submeshparent->sidenumrows;
    numsidecols_parent = submeshparent->sidenumcols;

    int trow, tcol, prow, pcol, mdex, pmdex;

	// an even vertex, transfer data from meshparent
	for (tcol = 0; tcol < numcols; tcol+=2) {
		for (trow = 0; trow < numrows; trow+=2) {

			mdex = tcol*numrows + trow;
			prow = trow/2;
			pcol = tcol/2;
			pmdex = pcol*numrows_parent + prow;

			submesh->topgrid[mdex].setvals(submeshparent->topgrid[pmdex].nodeloc,
				submeshparent->topgrid[pmdex].nodenorm,
				submeshparent->topgrid[pmdex].noderadius,
				submeshparent->topgrid[pmdex].uvt.u,
				submeshparent->topgrid[pmdex].uvt.v,
				submeshparent->topgrid[pmdex].uvt.t);
			submesh->topgrid[mdex].is_oddvert = false;

			submesh->bottomgrid[mdex].setvals(submeshparent->bottomgrid[pmdex].nodeloc,
				submeshparent->bottomgrid[pmdex].nodenorm,
				submeshparent->bottomgrid[pmdex].noderadius,
				submeshparent->bottomgrid[pmdex].uvt.u,
				submeshparent->bottomgrid[pmdex].uvt.v,
				submeshparent->bottomgrid[pmdex].uvt.t);
			submesh->bottomgrid[mdex].is_oddvert = false;

			// if parent was an involute, add child to involuteset for this level
			//    and copy involute position and normal from parent
			if (involuteset_top[meshlevel - 1].hasmember(pmdex)) {
				involuteset_top[meshlevel].insert(mdex);
				submesh->topgrid[mdex].true_nodeloc = submeshparent->topgrid[pmdex].true_nodeloc;
				submesh->topgrid[mdex].true_nodenorm = submeshparent->topgrid[pmdex].true_nodenorm;
			}
			if (involuteset_bottom[meshlevel - 1].hasmember(pmdex)) {
				involuteset_bottom[meshlevel].insert(mdex);
				submesh->bottomgrid[mdex].true_nodeloc = submeshparent->bottomgrid[pmdex].true_nodeloc;
				submesh->bottomgrid[mdex].true_nodenorm = submeshparent->bottomgrid[pmdex].true_nodenorm;
			}
		}
    }

	for (tcol = 0; tcol < numsidecols; tcol += 2) {
        for (trow = 0; trow < numsiderows; trow += 2) {
			mdex = tcol*numsiderows + trow;

			// an even vertex, transfer data from meshparent
			prow = trow/2;
			pcol = tcol/2;
			pmdex = pcol*numsiderows_parent + prow;

			submesh->sidegrid[mdex].setvals(submeshparent->sidegrid[pmdex].nodeloc,
				submeshparent->sidegrid[pmdex].nodenorm,
				submeshparent->sidegrid[pmdex].noderadius,
				submeshparent->sidegrid[pmdex].uvt.u,
				submeshparent->sidegrid[pmdex].uvt.v,
				submeshparent->sidegrid[pmdex].uvt.t);
			submesh->sidegrid[mdex].is_oddvert = false;

			// if parent was an involute, add child to involuteset for this level
			//    and copy involute position and normal from parent
			if (involuteset_side[meshlevel - 1].hasmember(pmdex)) {
				involuteset_side[meshlevel].insert(mdex);
				submesh->sidegrid[mdex].true_nodeloc = submeshparent->sidegrid[pmdex].true_nodeloc;
				submesh->sidegrid[mdex].true_nodenorm = submeshparent->sidegrid[pmdex].true_nodenorm;
			}
		}
    }

}

/******************************************************************************************/
/* averaging() -- does the averaging for (meshlevel) using Catmull-Clark rules			  */
/*	for regular quadmeshes.																  */
/*  Uses the in-place 1-neighborhood rules as derived in Thall Dissertation,			  */
/*     App.A, eq. A7 & A8.																  */
/******************************************************************************************/
void Subdivsurf::averaging(int meshlevel)
{

	int numrows, numcols, numsiderows, numsidecols;
    subdivgrid *submesh = &sub[meshlevel];

    numrows = submesh->subnumrows;
    numcols = submesh->subnumcols;
    numsiderows = submesh->sidenumrows;
    numsidecols = submesh->sidenumcols;

    int trow, tcol, mdex;

	// NOW, can do the averaging for the mesh using only local information of the new grid
	/****************************************************************************/
	/*   FIRST:  create the new face vertices
	/****************************************************************************/
	DbVector3 newloc, newnorm;
	Medcoord newuvt;
	double newradius;
	int mdexA, mdexB, mdexC, mdexD;

	for (tcol = 1; tcol < numcols; tcol+=2) {
		for (trow = 1; trow < numrows; trow+=2) {

			mdex = tcol*numrows + trow;
			mdexA = (tcol - 1)*numrows + (trow - 1);
			mdexB = (tcol - 1)*numrows + (trow + 1);
			mdexC = (tcol + 1)*numrows + (trow + 1);
			mdexD = (tcol + 1)*numrows + (trow - 1);

			// Do top faces
			newloc = submesh->topgrid[mdexA].nodeloc + submesh->topgrid[mdexB].nodeloc
				     + submesh->topgrid[mdexC].nodeloc + submesh->topgrid[mdexD].nodeloc;
			newloc /= 4.0;
			newnorm = submesh->topgrid[mdexA].nodenorm + submesh->topgrid[mdexB].nodenorm
				     + submesh->topgrid[mdexC].nodenorm + submesh->topgrid[mdexD].nodenorm;
			newnorm /= 4.0;
			newradius = submesh->topgrid[mdexA].noderadius + submesh->topgrid[mdexB].noderadius
				     + submesh->topgrid[mdexC].noderadius + submesh->topgrid[mdexD].noderadius;
			newradius /= 4.0;
			newuvt = submesh->topgrid[mdexA].uvt + submesh->topgrid[mdexB].uvt
				     + submesh->topgrid[mdexC].uvt + submesh->topgrid[mdexD].uvt;
			newuvt /= 4.0;

			submesh->topgrid[mdex].setvals(newloc, newnorm, newradius, newuvt.u, newuvt.v, newuvt.t);
			submesh->topgrid[mdex].is_oddvert = true;

			// Now bottom faces
			newloc = submesh->bottomgrid[mdexA].nodeloc + submesh->bottomgrid[mdexB].nodeloc
				     + submesh->bottomgrid[mdexC].nodeloc + submesh->bottomgrid[mdexD].nodeloc;
			newloc /= 4.0;
			newnorm = submesh->bottomgrid[mdexA].nodenorm + submesh->bottomgrid[mdexB].nodenorm
				     + submesh->bottomgrid[mdexC].nodenorm + submesh->bottomgrid[mdexD].nodenorm;
			newnorm /= 4.0;
			newradius = submesh->bottomgrid[mdexA].noderadius + submesh->bottomgrid[mdexB].noderadius
				     + submesh->bottomgrid[mdexC].noderadius + submesh->bottomgrid[mdexD].noderadius;
			newradius /= 4.0;
			newuvt = submesh->bottomgrid[mdexA].uvt + submesh->bottomgrid[mdexB].uvt
				     + submesh->bottomgrid[mdexC].uvt + submesh->bottomgrid[mdexD].uvt;
			newuvt /= 4.0;

			submesh->bottomgrid[mdex].setvals(newloc, newnorm, newradius, newuvt.u, newuvt.v, newuvt.t);
			submesh->bottomgrid[mdex].is_oddvert = true;
		}
    }

	// now do side odd faces
	for (tcol = 1; tcol < numsidecols; tcol += 2) {
        for (trow = 1; trow < numsiderows; trow += 2) {
			mdex = tcol*numsiderows + trow;
			mdexA = (tcol - 1)*numsiderows + (trow - 1);
			mdexD = (tcol + 1)*numsiderows + (trow - 1);

			// don't forget wraparound here
			if (trow == numsiderows - 1) {
				mdexB = (tcol - 1)*numsiderows;
				mdexC = (tcol + 1)*numsiderows;
			}
			else {
				mdexB = (tcol - 1)*numsiderows + (trow + 1);
				mdexC = (tcol + 1)*numsiderows + (trow + 1);
			}

			// Do side faces
			newloc = submesh->sidegrid[mdexA].nodeloc + submesh->sidegrid[mdexB].nodeloc
				     + submesh->sidegrid[mdexC].nodeloc + submesh->sidegrid[mdexD].nodeloc;
			newloc /= 4.0;
			newnorm = submesh->sidegrid[mdexA].nodenorm + submesh->sidegrid[mdexB].nodenorm
				     + submesh->sidegrid[mdexC].nodenorm + submesh->sidegrid[mdexD].nodenorm;
			newnorm /= 4.0;
			newradius = submesh->sidegrid[mdexA].noderadius + submesh->sidegrid[mdexB].noderadius
				     + submesh->sidegrid[mdexC].noderadius + submesh->sidegrid[mdexD].noderadius;
			newradius /= 4.0;
			newuvt = submesh->sidegrid[mdexA].uvt + submesh->sidegrid[mdexB].uvt
				     + submesh->sidegrid[mdexC].uvt + submesh->sidegrid[mdexD].uvt;
			newuvt /= 4.0;

			submesh->sidegrid[mdex].setvals(newloc, newnorm, newradius, newuvt.u, newuvt.v, newuvt.t);
			submesh->sidegrid[mdex].is_oddvert = true;
		}
	}

	/************************************************************************************************/
	/*   NOW:  create the new edge vertex (do rows, then columns), by averaging its edge neighbors
	/************************************************************************************************/
	Subneighborhood *nearverts = &vneighborhoods[meshlevel];
	Vertexneighbors *neighbors;
	int nighdex;

	for (tcol = 1; tcol < numcols; tcol+=2) {
		for (trow = 0; trow < numrows; trow+=2) {

			mdex = tcol*numrows + trow;
			neighbors = &nearverts->topneighbors[mdex];

			// Always have a 8-neighborhood, since new edge vertices
			newloc.set(0.0, 0.0, 0.0);
			newnorm.set(0.0, 0.0, 0.0);

			// Do top faces, summing only edge neighbors, not face neighbors
			//    NOTE: only do position and normal, here.  (u, v, t) and radius
			//          will be interpolated last for just the 2 even vertex neighbors
			for (nighdex = 0; nighdex < 8; nighdex += 2) {

				mdexA = (*neighbors)[nighdex].meshindex;
				switch ((*neighbors)[nighdex].whichmesh) {
				case TOP:
					newloc += submesh->topgrid[mdexA].nodeloc;
					newnorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					newloc += submesh->bottomgrid[mdexA].nodeloc;
					newnorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					newloc += submesh->sidegrid[mdexA].nodeloc;
					newnorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
			}
			newloc /= 4.0;
			newnorm /= 4.0;

			// The even neighbors are derived from the grid information
			mdexC = (tcol - 1)*numrows + trow;
			mdexD = (tcol + 1)*numrows + trow;

			newradius = submesh->topgrid[mdexC].noderadius + submesh->topgrid[mdexD].noderadius;
			newradius /= 2.0;
			newuvt = submesh->topgrid[mdexC].uvt + submesh->topgrid[mdexD].uvt;
			newuvt /= 2.0;

			submesh->topgrid[mdex].setvals(newloc, newnorm, newradius, newuvt.u, newuvt.v, newuvt.t);
			submesh->topgrid[mdex].is_oddvert = true;

			// Now bottom faces
			neighbors = &nearverts->bottomneighbors[mdex];

			// Always have a 8-neighborhood, since new edge vertices
			newloc.set(0.0, 0.0, 0.0);
			newnorm.set(0.0, 0.0, 0.0);

			// Do top faces, summing only edge neighbors, not face neighbors
			//    NOTE: only do position and normal, here.  (u, v, t) and radius
			//          will be interpolated last for just the 2 even vertex neighbors
			for (nighdex = 0; nighdex < 8; nighdex += 2) {

				mdexA = (*neighbors)[nighdex].meshindex;
				switch ((*neighbors)[nighdex].whichmesh) {
				case TOP:
					newloc += submesh->topgrid[mdexA].nodeloc;
					newnorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					newloc += submesh->bottomgrid[mdexA].nodeloc;
					newnorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					newloc += submesh->sidegrid[mdexA].nodeloc;
					newnorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
			}
			newloc /= 4.0;
			newnorm /= 4.0;

			// The even neighbors are derived from the grid information
			mdexC = (tcol - 1)*numrows + trow;
			mdexD = (tcol + 1)*numrows + trow;

			newradius = submesh->bottomgrid[mdexC].noderadius + submesh->bottomgrid[mdexD].noderadius;
			newradius /= 2.0;
			newuvt = submesh->bottomgrid[mdexC].uvt + submesh->bottomgrid[mdexD].uvt;
			newuvt /= 2.0;

			submesh->bottomgrid[mdex].setvals(newloc, newnorm, newradius, newuvt.u, newuvt.v, newuvt.t);
			submesh->bottomgrid[mdex].is_oddvert = true;
		}
    }
	// Now do the odd columns
	for (tcol = 0; tcol < numcols; tcol+=2) {
		for (trow = 1; trow < numrows; trow+=2) {

			mdex = tcol*numrows + trow;
			neighbors = &nearverts->topneighbors[mdex];

			// Always have a 8-neighborhood, since new edge vertices
			newloc.set(0.0, 0.0, 0.0);
			newnorm.set(0.0, 0.0, 0.0);

			// Do top faces, summing only edge neighbors, not face neighbors
			//    NOTE: only do position and normal, here.  (u, v, t) and radius
			//          will be interpolated last for just the 2 even vertex neighbors
			for (nighdex = 0; nighdex < 8; nighdex += 2) {

				mdexA = (*neighbors)[nighdex].meshindex;
				switch ((*neighbors)[nighdex].whichmesh) {
				case TOP:
					newloc += submesh->topgrid[mdexA].nodeloc;
					newnorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					newloc += submesh->bottomgrid[mdexA].nodeloc;
					newnorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					newloc += submesh->sidegrid[mdexA].nodeloc;
					newnorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
			}
			newloc /= 4.0;
			newnorm /= 4.0;

			// The even neighbors are derived from the grid information
			mdexC = tcol*numrows + trow - 1;
			mdexD = tcol*numrows + trow + 1;

			newradius = submesh->topgrid[mdexC].noderadius + submesh->topgrid[mdexD].noderadius;
			newradius /= 2.0;
			newuvt = submesh->topgrid[mdexC].uvt + submesh->topgrid[mdexD].uvt;
			newuvt /= 2.0;

			submesh->topgrid[mdex].setvals(newloc, newnorm, newradius, newuvt.u, newuvt.v, newuvt.t);
			submesh->topgrid[mdex].is_oddvert = true;

			// Now bottom faces
			neighbors = &nearverts->bottomneighbors[mdex];

			// Always have a 8-neighborhood, since new edge vertices
			newloc.set(0.0, 0.0, 0.0);
			newnorm.set(0.0, 0.0, 0.0);

			// Do bottom faces, summing only edge neighbors, not face neighbors
			//    NOTE: only do position and normal, here.  (u, v, t) and radius
			//          will be interpolated last for just the 2 even vertex neighbors
			for (nighdex = 0; nighdex < 8; nighdex += 2) {

				mdexA = (*neighbors)[nighdex].meshindex;
				switch ((*neighbors)[nighdex].whichmesh) {
				case TOP:
					newloc += submesh->topgrid[mdexA].nodeloc;
					newnorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					newloc += submesh->bottomgrid[mdexA].nodeloc;
					newnorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					newloc += submesh->sidegrid[mdexA].nodeloc;
					newnorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
			}
			newloc /= 4.0;
			newnorm /= 4.0;

			// The even neighbors are derived from the grid information
			mdexC = tcol*numrows + trow - 1;
			mdexD = tcol*numrows + trow + 1;

			newradius = submesh->bottomgrid[mdexC].noderadius + submesh->bottomgrid[mdexD].noderadius;
			newradius /= 2.0;
			newuvt = submesh->bottomgrid[mdexC].uvt + submesh->bottomgrid[mdexD].uvt;
			newuvt /= 2.0;

			submesh->bottomgrid[mdex].setvals(newloc, newnorm, newradius, newuvt.u, newuvt.v, newuvt.t);
			submesh->bottomgrid[mdex].is_oddvert = true;
		}
    }

	// NOW, do the side odd edges
	//   NOW:  create the new edge vertex (do rows, then columns), by averaging its edge neighbors
	for (tcol = 1; tcol < numsidecols; tcol+=2) {
		for (trow = 0; trow < numsiderows; trow+=2) {

			mdex = tcol*numsiderows + trow;
			neighbors = &nearverts->sideneighbors[mdex];

			// Always have a 8-neighborhood, since new edge vertices
			newloc.set(0.0, 0.0, 0.0);
			newnorm.set(0.0, 0.0, 0.0);

			// Do top faces, summing only edge neighbors, not face neighbors
			//    NOTE: only do position and normal, here.  (u, v, t) and radius
			//          will be interpolated last for just the 2 even vertex neighbors
			for (nighdex = 0; nighdex < 8; nighdex += 2) {

				mdexA = (*neighbors)[nighdex].meshindex;
				switch ((*neighbors)[nighdex].whichmesh) {
				case TOP:
					newloc += submesh->topgrid[mdexA].nodeloc;
					newnorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					newloc += submesh->bottomgrid[mdexA].nodeloc;
					newnorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					newloc += submesh->sidegrid[mdexA].nodeloc;
					newnorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
			}
			newloc /= 4.0;
			newnorm /= 4.0;

			// The even neighbors are derived from the grid information
			mdexC = (tcol - 1)*numsiderows + trow;
			mdexD = (tcol + 1)*numsiderows + trow;

			newradius = submesh->sidegrid[mdexC].noderadius + submesh->sidegrid[mdexD].noderadius;
			newradius /= 2.0;
			newuvt = submesh->sidegrid[mdexC].uvt + submesh->sidegrid[mdexD].uvt;
			newuvt /= 2.0;

			submesh->sidegrid[mdex].setvals(newloc, newnorm, newradius, newuvt.u, newuvt.v, newuvt.t);
			submesh->sidegrid[mdex].is_oddvert = true;
		}
    }
	// Now do the odd columns
	for (tcol = 0; tcol < numsidecols; tcol+=2) {
		for (trow = 1; trow < numsiderows; trow+=2) {

			mdex = tcol*numsiderows + trow;
			neighbors = &nearverts->sideneighbors[mdex];

			// Always have a 8-neighborhood, since new edge vertices
			newloc.set(0.0, 0.0, 0.0);
			newnorm.set(0.0, 0.0, 0.0);

			// Do top faces, summing only edge neighbors, not face neighbors
			//    NOTE: only do position and normal, here.  (u, v, t) and radius
			//          will be interpolated last for just the 2 even vertex neighbors
			for (nighdex = 0; nighdex < 8; nighdex += 2) {

				mdexA = (*neighbors)[nighdex].meshindex;
				switch ((*neighbors)[nighdex].whichmesh) {
				case TOP:
					newloc += submesh->topgrid[mdexA].nodeloc;
					newnorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					newloc += submesh->bottomgrid[mdexA].nodeloc;
					newnorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					newloc += submesh->sidegrid[mdexA].nodeloc;
					newnorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
			}
			newloc /= 4.0;
			newnorm /= 4.0;

			// The even neighbors are derived from the grid information
			mdexC = tcol*numsiderows + trow - 1;
			// don't forget wraparound here
			if (trow == numsiderows - 1) 
				mdexD = tcol*numsiderows;
			else
				mdexD = tcol*numsiderows + trow + 1;

			newradius = submesh->sidegrid[mdexC].noderadius + submesh->sidegrid[mdexD].noderadius;
			newradius /= 2.0;
			newuvt = submesh->sidegrid[mdexC].uvt + submesh->sidegrid[mdexD].uvt;
			newuvt /= 2.0;

			submesh->sidegrid[mdex].setvals(newloc, newnorm, newradius, newuvt.u, newuvt.v, newuvt.t);
			submesh->sidegrid[mdex].is_oddvert = true;
		}
    }

	/****************************************************************************/
	/* NOW:  compute weighted sum of vertices in 1-neighborhood of the even vertex
	/*    to compute its new value
	/****************************************************************************/
	for (tcol = 0; tcol < numcols; tcol+=2) {
		for (trow = 0; trow < numrows; trow+=2) {

			mdex = tcol*numrows + trow;
			neighbors = &nearverts->topneighbors[mdex];

			// Do top faces, summing only edge neighbors, not face neighbors
			//    NOTE: only do position and normal, here.  (u, v, t) and radius
			//          will be interpolated last for just the 2 even vertex neighbors

			// Formula for this is v^{i+1} = (1 - 3/n)v^i + 1/n^2 * Sum[4*e^{i+1} - f^{i+1}]
			//                                                        j    j         j
			// Thus, need only local information, since v^i is stored at each even vertex.
			// The derivation for this formula is in Thall Dissertation App. A, as Eq. A8.

			int valence = neighbors->degree()/2;	// n = valence is number of edge-neighbors

			newloc = submesh->topgrid[mdex].nodeloc * (1.0 - 3.0/valence);
			newnorm = submesh->topgrid[mdex].nodenorm * (1.0 - 3.0/valence);

			DbVector3 edgeloc(0.0, 0.0, 0.0);
			DbVector3 faceloc(0.0, 0.0, 0.0);
			DbVector3 edgenorm(0.0, 0.0, 0.0);
			DbVector3 facenorm(0.0, 0.0, 0.0);
			for (nighdex = 0; nighdex < neighbors->degree(); nighdex += 2) {

				mdexA = (*neighbors)[nighdex].meshindex;
				switch ((*neighbors)[nighdex].whichmesh) {
				case TOP:
					edgeloc += submesh->topgrid[mdexA].nodeloc;
					edgenorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					edgeloc += submesh->bottomgrid[mdexA].nodeloc;
					edgenorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					edgeloc += submesh->sidegrid[mdexA].nodeloc;
					edgenorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
				mdexA = (*neighbors)[nighdex + 1].meshindex;
				switch ((*neighbors)[nighdex + 1].whichmesh) {
				case TOP:
					faceloc += submesh->topgrid[mdexA].nodeloc;
					facenorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					faceloc += submesh->bottomgrid[mdexA].nodeloc;
					facenorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					faceloc += submesh->sidegrid[mdexA].nodeloc;
					facenorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
			}
			newloc += (4.0*edgeloc - faceloc)/(valence*valence);
			newnorm += (4.0*edgeloc - faceloc)/(valence*valence);
			// The even neighbors keep all other attributes unchanged---r, (u,v,t), nodeparents
			//    and involute-set status
			submesh->topgrid[mdex].nodeloc = newloc;
			submesh->topgrid[mdex].nodenorm = newnorm;

			// Now bottom faces

			neighbors = &nearverts->bottomneighbors[mdex];
			valence = neighbors->degree()/2;	// n = valence is number of edge-neighbors

			newloc = submesh->bottomgrid[mdex].nodeloc * (1.0 - 3.0/valence);
			newnorm = submesh->bottomgrid[mdex].nodenorm * (1.0 - 3.0/valence);

			edgeloc.set(0.0, 0.0, 0.0);
			faceloc.set(0.0, 0.0, 0.0);
			edgenorm.set(0.0, 0.0, 0.0);
			facenorm.set(0.0, 0.0, 0.0);
			for (nighdex = 0; nighdex < neighbors->degree(); nighdex += 2) {

				mdexA = (*neighbors)[nighdex].meshindex;
				switch ((*neighbors)[nighdex].whichmesh) {
				case TOP:
					edgeloc += submesh->topgrid[mdexA].nodeloc;
					edgenorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					edgeloc += submesh->bottomgrid[mdexA].nodeloc;
					edgenorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					edgeloc += submesh->sidegrid[mdexA].nodeloc;
					edgenorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
				mdexA = (*neighbors)[nighdex + 1].meshindex;
				switch ((*neighbors)[nighdex + 1].whichmesh) {
				case TOP:
					faceloc += submesh->topgrid[mdexA].nodeloc;
					facenorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					faceloc += submesh->bottomgrid[mdexA].nodeloc;
					facenorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					faceloc += submesh->sidegrid[mdexA].nodeloc;
					facenorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
			}
			newloc += (4.0*edgeloc - faceloc)/(valence*valence);
			newnorm += (4.0*edgeloc - faceloc)/(valence*valence);
			// The even neighbors keep all other attributes unchanged---r, (u,v,t),
			//    and involute-set status
			submesh->bottomgrid[mdex].nodeloc = newloc;
			submesh->bottomgrid[mdex].nodenorm = newnorm;
		}
    }

	for (tcol = 0; tcol < numsidecols; tcol += 2) {
        for (trow = 0; trow < numsiderows; trow += 2) {
			mdex = tcol*numsiderows + trow;

			neighbors = &nearverts->sideneighbors[mdex];
			int valence = neighbors->degree()/2;	// n = valence is number of edge-neighbors

			newloc = submesh->sidegrid[mdex].nodeloc * (1.0 - 3.0/valence);
			newnorm = submesh->sidegrid[mdex].nodenorm * (1.0 - 3.0/valence);

			DbVector3 edgeloc(0.0, 0.0, 0.0);
			DbVector3 faceloc(0.0, 0.0, 0.0);
			DbVector3 edgenorm(0.0, 0.0, 0.0);
			DbVector3 facenorm(0.0, 0.0, 0.0);
			for (nighdex = 0; nighdex < neighbors->degree(); nighdex += 2) {

				mdexA = (*neighbors)[nighdex].meshindex;
				switch ((*neighbors)[nighdex].whichmesh) {
				case TOP:
					edgeloc += submesh->topgrid[mdexA].nodeloc;
					edgenorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					edgeloc += submesh->bottomgrid[mdexA].nodeloc;
					edgenorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					edgeloc += submesh->sidegrid[mdexA].nodeloc;
					edgenorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
				mdexA = (*neighbors)[nighdex + 1].meshindex;
				switch ((*neighbors)[nighdex + 1].whichmesh) {
				case TOP:
					faceloc += submesh->topgrid[mdexA].nodeloc;
					facenorm += submesh->topgrid[mdexA].nodenorm;
					break;
				case BOTTOM:
					faceloc += submesh->bottomgrid[mdexA].nodeloc;
					facenorm += submesh->bottomgrid[mdexA].nodenorm;
					break;
				case SIDE:
					faceloc += submesh->sidegrid[mdexA].nodeloc;
					facenorm += submesh->sidegrid[mdexA].nodenorm;
					break;
				}
			}
			newloc += (4.0*edgeloc - faceloc)/(valence*valence);
			newnorm += (4.0*edgeloc - faceloc)/(valence*valence);
			// The even neighbors keep all other attributes unchanged---r, (u,v,t),
			//    and involute-set status
			submesh->sidegrid[mdex].nodeloc = newloc;
			submesh->sidegrid[mdex].nodenorm = newnorm;
		}
    }
}

void Tileneighbors::load(int tdex0, int tdex1, int tdex2, int tdex3,
								int tdex4, int tdex5, int tdex6, int tdex7)
{
	neighbors[0] = tdex0;
	neighbors[1] = tdex1;
	neighbors[2] = tdex2;
	neighbors[3] = tdex3;
	neighbors[4] = tdex4;
	neighbors[5] = tdex5;
	neighbors[6] = tdex6;
	neighbors[7] = tdex7;
}

/********************************************************************************/
/* get_tileneighbors() -- create neighborlist associated with tileset produced	*/
/*    by mod_subdiv() for current activesubmesh.  Contains a list of numtiles	*/
/*    Tileneighbors arrays, each giving index values associated with neighbors	*/
/*    of indexing tilenumber.  Tileneighbors (int[8]) typedefed in Subdivsurf.h	*/
/*    If fewer than 8 neighbors, last elements in list will be == -1.			*/
/********************************************************************************/
void Subdivsurf::get_tileneighbors(int *ntiles, Tileneighbors **neighborlist)
{
	int numrows, numcols, numsiderows, numsidecols;

    subdivgrid *submesh = activesubmesh;

	if (submesh == NULL) {
		fprintf(stderr, "no active mesh in Subdivsurf::get_tileneighbor\n");
		exit(0);
	}

	// the below are for the meshes, NOT the tiles.
    numrows = submesh->subnumrows;
    numcols = submesh->subnumcols;
    numsiderows = submesh->sidenumrows;
    numsidecols = submesh->sidenumcols;

	// variables for tiles
	int nrows, ncols, nsrows, nscols, numtiles;
	nrows = numrows - 1;
	ncols = numcols - 1;
	nsrows = numsiderows;  // because of wraparound on edge, num-vertices == num-tiles along row
	nscols = numsidecols - 1;

	// some indexing offset variables
	int B = nrows*ncols;	// offset in mesh between top and bottom mesh indices
	int C = 2*nrows*ncols;  // offset to beginning of side mesh
	int E = 2*nrows + 2*ncols;   // edgelength of sidemesh (same as nsrows, I hope)
	                             //   ---offset for each edgerow
	if (E != nsrows) {
		fprintf(stderr, "problems in get_tileneighbors()\n");
	    exit(0);
	}

	numtiles = 2*nrows*ncols + nsrows*nscols;

	*neighborlist = new Tileneighbors[numtiles];
	*ntiles = numtiles;

	int col, row;
	// Fill in first top and bottom inner faces
	int t_dex, b_dex;
	for (col = 1; col < ncols - 1; col++) {
		for (row = 1; row < nrows - 1; row++) {
			t_dex = col*nrows + row;
			b_dex = t_dex + B;

			(*neighborlist)[t_dex].load(t_dex - nrows - 1, t_dex - nrows, t_dex - nrows + 1, 
										t_dex - 1, t_dex + 1,
										t_dex + nrows - 1, t_dex + nrows, t_dex + nrows + 1);
			(*neighborlist)[b_dex].load(b_dex - nrows - 1, b_dex - nrows, b_dex - nrows + 1, 
										b_dex - 1, b_dex + 1,
										b_dex + nrows - 1, b_dex + nrows, b_dex + nrows + 1);
		}
	}

	// Fill in side inner faces
	int s_dex;
	for (col = 1; col < nscols - 1; col++) {
		for (row = 1; row < nsrows - 1; row++) {
			s_dex = C + col*nsrows + row;

			(*neighborlist)[s_dex].load(s_dex - E - 1, s_dex - E, s_dex - E + 1, 
				                        s_dex - 1, s_dex + 1,
				                        s_dex + E - 1, s_dex + E, s_dex + E + 1);
		}
	}


	int ts_dex, bs_dex;

	// Fill in inner edge of top and bottom col==0
	col = 0;
	for (row = 1; row < nrows - 1; row++) {
		t_dex = col*nrows + row;
		b_dex = t_dex + B;

		// middle of 3 elements on edge bounding (col, row) == (0, row) on top and bottom
		ts_dex = C + row;
		bs_dex = ts_dex + (nscols - 1)*E;

		(*neighborlist)[t_dex].load(t_dex + nrows - 1, t_dex + nrows, t_dex + nrows + 1, 
				                    t_dex - 1, t_dex + 1,
				                    ts_dex - 1, ts_dex, ts_dex + 1);

		(*neighborlist)[b_dex].load(b_dex + nrows - 1, b_dex + nrows, b_dex + nrows + 1, 
				                    b_dex - 1, b_dex + 1,
				                    bs_dex - 1, bs_dex, bs_dex + 1);
	}

	// Fill in inner edge of top and bottom col==ncols - 1
	col = ncols - 1;
	for (row = 1; row < nrows - 1; row++) {
		t_dex = col*nrows + row;
		b_dex = t_dex + B;

		// middle of 3 elements on edge bounding (col, row) == (ncols - 1, row) on top and bottom
		ts_dex = C + 2*nrows + ncols - 1 - row;
		bs_dex = ts_dex + (nscols - 1)*E;

		(*neighborlist)[t_dex].load(t_dex - nrows - 1, t_dex - nrows, t_dex - nrows + 1, 
				                    t_dex - 1, t_dex + 1,
				                    ts_dex - 1, ts_dex, ts_dex + 1);

		(*neighborlist)[b_dex].load(b_dex - nrows - 1, b_dex - nrows, b_dex - nrows + 1, 
				                    b_dex - 1, b_dex + 1,
				                    bs_dex - 1, bs_dex, bs_dex + 1);
	}

	// Fill in inner edge of top and bottom row == 0
	row = 0;
	for (col = 1; col < ncols - 1; col++) {
		t_dex = col*nrows + row;
		b_dex = t_dex + B;

		// middle of 3 elements on edge bounding (col, row) == (col, 0) on top and bottom
		ts_dex = C + 2*nrows + 2*ncols - 1 - col;
		bs_dex = ts_dex + (nscols - 1)*E;

		(*neighborlist)[t_dex].load(t_dex + nrows, t_dex + nrows + 1, t_dex + 1, 
				                    t_dex - nrows, t_dex - nrows + 1,
				                    ts_dex - 1, ts_dex, ts_dex + 1);

		(*neighborlist)[b_dex].load(b_dex + nrows, b_dex + nrows + 1, b_dex + 1, 
				                    b_dex - nrows, b_dex - nrows + 1,
				                    bs_dex - 1, bs_dex, bs_dex + 1);
	}

	// Fill in inner edge of top and bottom row == nrows - 1
	row = nrows - 1;
	for (col = 1; col < ncols - 1; col++) {
		t_dex = col*nrows + row;
		b_dex = t_dex + B;

		// middle of 3 elements on edge bounding (col, row) == (col, nrows - 1) on top and bottom
		ts_dex = C + nrows + col;
		bs_dex = ts_dex + (nscols - 1)*E;

		(*neighborlist)[t_dex].load(t_dex + nrows, t_dex + nrows - 1, t_dex - 1, 
				                    t_dex - nrows, t_dex - nrows - 1,
				                    ts_dex - 1, ts_dex, ts_dex + 1);

		(*neighborlist)[b_dex].load(b_dex + nrows, b_dex + nrows - 1, b_dex - 1, 
				                    b_dex - nrows, b_dex - nrows - 1,
				                    bs_dex - 1, bs_dex, bs_dex + 1);
	}

	// Fill in top and bottom corners

	// 4 edge elements adjacent on top and bottom
	int ts_dex1, ts_dex2, ts_dex3, ts_dex4;
	int bs_dex1, bs_dex2, bs_dex3, bs_dex4;

	// CORNER 1
	row = 0;
	col = 0;
	t_dex = col*nrows + row;
	b_dex = t_dex + B;

	ts_dex1 = C + 2*nrows + 2*ncols - 2;
	ts_dex2 = ts_dex1 + 1;
	ts_dex3 = C;
	ts_dex4 = C + 1;

	bs_dex1 = ts_dex1 + (nscols - 1)*E;
	bs_dex2 = ts_dex2 + (nscols - 1)*E;
	bs_dex3 = ts_dex3 + (nscols - 1)*E;
	bs_dex4 = ts_dex4 + (nscols - 1)*E;

	(*neighborlist)[t_dex].load(t_dex + nrows, t_dex + nrows + 1, t_dex + 1, 
				                ts_dex1, ts_dex2, ts_dex3, ts_dex4, -1);

	(*neighborlist)[b_dex].load(b_dex + nrows, b_dex + nrows + 1, b_dex + 1, 
				                bs_dex1, bs_dex2, bs_dex3, bs_dex4, -1);

	// CORNER 2
	row = nrows - 1;
	col = 0;
	t_dex = col*nrows + row;
	b_dex = t_dex + B;

	ts_dex1 = C + nrows - 2;
	ts_dex2 = ts_dex1 + 1;
	ts_dex3 = ts_dex1 + 2;
	ts_dex4 = ts_dex1 + 3;

	bs_dex1 = ts_dex1 + (nscols - 1)*E;
	bs_dex2 = ts_dex2 + (nscols - 1)*E;
	bs_dex3 = ts_dex3 + (nscols - 1)*E;
	bs_dex4 = ts_dex4 + (nscols - 1)*E;

	(*neighborlist)[t_dex].load(t_dex + nrows, t_dex + nrows - 1, t_dex - 1, 
				                ts_dex1, ts_dex2, ts_dex3, ts_dex4, -1);

	(*neighborlist)[b_dex].load(b_dex + nrows, b_dex + nrows - 1, b_dex - 1, 
				                bs_dex1, bs_dex2, bs_dex3, bs_dex4, -1);

	// CORNER 3
	row = nrows - 1;
	col = ncols - 1;
	t_dex = col*nrows + row;
	b_dex = t_dex + B;

	ts_dex1 = C + nrows + ncols - 2;
	ts_dex2 = ts_dex1 + 1;
	ts_dex3 = ts_dex1 + 2;
	ts_dex4 = ts_dex1 + 3;

	bs_dex1 = ts_dex1 + (nscols - 1)*E;
	bs_dex2 = ts_dex2 + (nscols - 1)*E;
	bs_dex3 = ts_dex3 + (nscols - 1)*E;
	bs_dex4 = ts_dex4 + (nscols - 1)*E;

	(*neighborlist)[t_dex].load(t_dex - nrows, t_dex - nrows - 1, t_dex - 1, 
				                ts_dex1, ts_dex2, ts_dex3, ts_dex4, -1);

	(*neighborlist)[b_dex].load(b_dex - nrows, b_dex - nrows - 1, b_dex - 1, 
				                bs_dex1, bs_dex2, bs_dex3, bs_dex4, -1);

	// CORNER 4
	row = 0;
	col = ncols - 1;
	t_dex = col*nrows + row;
	b_dex = t_dex + B;

	ts_dex1 = C + 2*nrows + ncols - 2;
	ts_dex2 = ts_dex1 + 1;
	ts_dex3 = ts_dex1 + 2;
	ts_dex4 = ts_dex1 + 3;

	bs_dex1 = ts_dex1 + (nscols - 1)*E;
	bs_dex2 = ts_dex2 + (nscols - 1)*E;
	bs_dex3 = ts_dex3 + (nscols - 1)*E;
	bs_dex4 = ts_dex4 + (nscols - 1)*E;

	(*neighborlist)[t_dex].load(t_dex - nrows, t_dex - nrows + 1, t_dex + 1, 
				                ts_dex1, ts_dex2, ts_dex3, ts_dex4, -1);

	(*neighborlist)[b_dex].load(b_dex - nrows, b_dex - nrows + 1, b_dex + 1, 
				                bs_dex1, bs_dex2, bs_dex3, bs_dex4, -1);

	// Fill in top and bottom inner edges of sides

	col = 0;
	for (row = 1; row < nrows - 1; row++) {

		ts_dex = C + row;
		bs_dex = ts_dex + (nscols - 1)*E;

		t_dex = col*nrows + row;
		b_dex = t_dex + B;

		(*neighborlist)[ts_dex].load(ts_dex + E - 1, ts_dex + E, ts_dex + E + 1,
			                        ts_dex - 1, ts_dex + 1, t_dex - 1, t_dex, t_dex + 1);

		(*neighborlist)[bs_dex].load(bs_dex - E - 1, bs_dex - E, bs_dex - E + 1,
			                        bs_dex - 1, bs_dex + 1, b_dex - 1, b_dex, b_dex + 1);
	}


	col = ncols - 1;
	for (row = 1; row < nrows - 1; row++) {

		ts_dex = C + 2*nrows + ncols - 1 - row;
		bs_dex = ts_dex + (nscols - 1)*E;

		t_dex = col*nrows + row;
		b_dex = t_dex + B;

		(*neighborlist)[ts_dex].load(ts_dex + E - 1, ts_dex + E, ts_dex + E + 1,
			                        ts_dex - 1, ts_dex + 1, t_dex - 1, t_dex, t_dex + 1);

		(*neighborlist)[bs_dex].load(bs_dex - E - 1, bs_dex - E, bs_dex - E + 1,
			                        bs_dex - 1, bs_dex + 1, b_dex - 1, b_dex, b_dex + 1);
	}

	row = 0;
	for (col = 1; col < ncols - 1; col++) {

		ts_dex = C + 2*nrows + 2*ncols - 1 - col;
		bs_dex = ts_dex + (nscols - 1)*E;

		t_dex = col*nrows + row;
		b_dex = t_dex + B;

		(*neighborlist)[ts_dex].load(ts_dex + E - 1, ts_dex + E, ts_dex + E + 1,
			                        ts_dex - 1, ts_dex + 1, t_dex - nrows, t_dex, t_dex + nrows);

		(*neighborlist)[bs_dex].load(bs_dex - E - 1, bs_dex - E, bs_dex - E + 1,
			                        bs_dex - 1, bs_dex + 1, b_dex - nrows, b_dex, b_dex + nrows);
	}

	row = nrows - 1;
	for (col = 1; col < ncols - 1; col++) {

		ts_dex = C + nrows + col;
		bs_dex = ts_dex + (nscols - 1)*E;

		t_dex = col*nrows + row;
		b_dex = t_dex + B;

		(*neighborlist)[ts_dex].load(ts_dex + E - 1, ts_dex + E, ts_dex + E + 1,
			                        ts_dex - 1, ts_dex + 1, t_dex - nrows, t_dex, t_dex + nrows);

		(*neighborlist)[bs_dex].load(bs_dex - E - 1, bs_dex - E, bs_dex - E + 1,
			                        bs_dex - 1, bs_dex + 1, b_dex - nrows, b_dex, b_dex + nrows);
	}

	// Fill in side edge faces for siderow = 0 and siderow = nsrows
	row = 0;
	for (col = 1; col < nscols - 1; col++) {

		s_dex = C + col*nsrows + row;

		// last 3 are wrap-around vertices
		(*neighborlist)[s_dex].load(s_dex - E, s_dex - E + 1, s_dex + 1, s_dex + E, s_dex + E + 1,
			                        s_dex - 1, s_dex + E - 1, s_dex + 2*E - 1);
	}

	row = nsrows - 1;
	for (col = 1; col < nscols - 1; col++) {

		s_dex = C + col*nsrows + row;

		// last 3 are wrap-around vertices
		(*neighborlist)[s_dex].load(s_dex - E - 1, s_dex - E, s_dex - 1, s_dex + E - 1, s_dex + E,
			                        s_dex - 2*E + 1, s_dex - E + 1, s_dex + 1);
	}

	// NOW, endlich, fill in corners on sides, 16 cases
	// ---can't think of one clever way to solve this one

	// WRAPAROUND side corners, row = col = 0
    // for tile 
	s_dex = C + E - 1;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(C + 2*E - 2, C + 2*E - 1, C + E, C + E - 2, C, nrows, 0, -1);

	// for tile 
	s_dex = C;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(C + 2*E - 1, C + E , C + E + 1, C + E - 1, C + 1, 0, 1, -1);

	// for tile 
	s_dex = C + nscols*E - 1;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(C + (nscols - 1)*E - 2, C + (nscols - 1)*E - 1, C + (nscols - 2)*E,
		                        C + nscols*E - 2, C + (nscols - 1)*E, nrows + B, B, -1);

	// for tile 
	s_dex = C + (nscols - 1)*E;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(C + (nscols - 1)*E - 1, C + (nscols - 2)*E, C + (nscols - 2)*E + 1,
		                        C + nscols*E - 1, C + (nscols - 1)*E + 1, B, B + 1, -1);

	// Other side corners

	// row = nrows - 1, col = 0

	// EACH pair is a top and a bottom
	s_dex = C + nrows - 1;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex + E - 1, s_dex + E, s_dex + E + 1, s_dex - 1, s_dex + 1,
	                            nrows - 2, nrows - 1, -1);

	s_dex = C + (nscols - 1)*E + nrows - 1;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex - E - 1, s_dex - E, s_dex - E + 1, s_dex - 1, s_dex + 1,
	                            nrows - 2 + B, nrows - 1 + B, -1);

	// next pair
	s_dex = C + nrows;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex + E - 1, s_dex + E, s_dex + E + 1, s_dex - 1, s_dex + 1,
	                            nrows - 1, 2*nrows - 1, -1);

	s_dex = C + (nscols - 1)*E + nrows;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex - E - 1, s_dex - E, s_dex - E + 1, s_dex - 1, s_dex + 1,
	                            nrows - 1 + B, 2*nrows - 1 + B, -1);

	// row = nrows - 1, col = ncols - 1

	// EACH pair is a top and a bottom
	s_dex = C + nrows + ncols - 1;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex + E - 1, s_dex + E, s_dex + E + 1, s_dex - 1, s_dex + 1,
	                            (ncols - 1)*nrows - 1, ncols*nrows - 1, -1);

	s_dex = C + (nscols - 1)*E + nrows + ncols - 1;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex - E - 1, s_dex - E, s_dex - E + 1, s_dex - 1, s_dex + 1,
	                            (ncols - 1)*nrows - 1 + B, ncols*nrows - 1 + B, -1);

	// next pair
	s_dex = C + nrows + ncols;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex + E - 1, s_dex + E, s_dex + E + 1, s_dex - 1, s_dex + 1,
	                            ncols*nrows - 1, ncols*nrows - 2, -1);

	s_dex = C + (nscols - 1)*E + nrows + ncols;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex - E - 1, s_dex - E, s_dex - E + 1, s_dex - 1, s_dex + 1,
	                            ncols*nrows - 1 + B, ncols*nrows - 2 + B, -1);

	// row = 0, col = ncols - 1

	// EACH pair is a top and a bottom
	s_dex = C + 2*nrows + ncols - 1;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex + E - 1, s_dex + E, s_dex + E + 1, s_dex - 1, s_dex + 1,
	                            (ncols - 1)*nrows + 1, (ncols - 1)*nrows, -1);

	s_dex = C + (nscols - 1)*E + 2*nrows + ncols - 1;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex - E - 1, s_dex - E, s_dex - E + 1, s_dex - 1, s_dex + 1,
	                            (ncols - 1)*nrows + 1 + B, (ncols - 1)*nrows + B, -1);

	// next pair
	s_dex = C + 2*nrows + ncols;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex + E - 1, s_dex + E, s_dex + E + 1, s_dex - 1, s_dex + 1,
	                            (ncols - 1)*nrows, (ncols - 2)*nrows, -1);

	s_dex = C + (nscols - 1)*E + 2*nrows + ncols;

	// [5] and [6] are the two faces on the top
	(*neighborlist)[s_dex].load(s_dex - E - 1, s_dex - E, s_dex - E + 1, s_dex - 1, s_dex + 1,
	                            (ncols - 1)*nrows + B, (ncols - 2)*nrows + B, -1);
}

inline void load_vneighbor8(Vertexneighbors *vneigh,
			  MeshID m0, MeshID m1, MeshID m2, MeshID m3, MeshID m4, MeshID m5, MeshID m6, MeshID m7,
			  int mdex0, int mdex1, int mdex2, int mdex3, int mdex4, int mdex5, int mdex6, int mdex7)
{
	(*vneigh).degree() = 8;
	(*vneigh)[0].meshindex = mdex0;
	(*vneigh)[0].whichmesh = m0;
	(*vneigh)[1].meshindex = mdex1;
	(*vneigh)[1].whichmesh = m1;
	(*vneigh)[2].meshindex = mdex2;
	(*vneigh)[2].whichmesh = m2;
	(*vneigh)[3].meshindex = mdex3;
	(*vneigh)[3].whichmesh = m3;
	(*vneigh)[4].meshindex = mdex4;
	(*vneigh)[4].whichmesh = m4;
	(*vneigh)[5].meshindex = mdex5;
	(*vneigh)[5].whichmesh = m5;
	(*vneigh)[6].meshindex = mdex6;
	(*vneigh)[6].whichmesh = m6;
	(*vneigh)[7].meshindex = mdex7;
	(*vneigh)[7].whichmesh = m7;
}

inline void load_vneighbor6(Vertexneighbors *vneigh,
			  MeshID m0, MeshID m1, MeshID m2, MeshID m3, MeshID m4, MeshID m5,
			  int mdex0, int mdex1, int mdex2, int mdex3, int mdex4, int mdex5)
{
	(*vneigh).degree() = 6;
	(*vneigh)[0].meshindex = mdex0;
	(*vneigh)[0].whichmesh = m0;
	(*vneigh)[1].meshindex = mdex1;
	(*vneigh)[1].whichmesh = m1;
	(*vneigh)[2].meshindex = mdex2;
	(*vneigh)[2].whichmesh = m2;
	(*vneigh)[3].meshindex = mdex3;
	(*vneigh)[3].whichmesh = m3;
	(*vneigh)[4].meshindex = mdex4;
	(*vneigh)[4].whichmesh = m4;
	(*vneigh)[5].meshindex = mdex5;
	(*vneigh)[5].whichmesh = m5;
	(*vneigh)[6].meshindex = -1;
	(*vneigh)[6].whichmesh = TOP;
	(*vneigh)[7].meshindex = -1;
	(*vneigh)[7].whichmesh = TOP;
}

inline void copy_vneighbor(Vertexneighbors *newneigh, Vertexneighbors *oldneigh)\
{
	(*newneigh).degree() = (*oldneigh).degree();
	(*newneigh)[0].meshindex = (*oldneigh)[0].meshindex;
	(*newneigh)[0].whichmesh = (*oldneigh)[0].whichmesh;
	(*newneigh)[1].meshindex = (*oldneigh)[1].meshindex;
	(*newneigh)[1].whichmesh = (*oldneigh)[1].whichmesh;
	(*newneigh)[2].meshindex = (*oldneigh)[2].meshindex;
	(*newneigh)[2].whichmesh = (*oldneigh)[2].whichmesh;
	(*newneigh)[3].meshindex = (*oldneigh)[3].meshindex;
	(*newneigh)[3].whichmesh = (*oldneigh)[3].whichmesh;
	(*newneigh)[4].meshindex = (*oldneigh)[4].meshindex;
	(*newneigh)[4].whichmesh = (*oldneigh)[4].whichmesh;
	(*newneigh)[5].meshindex = (*oldneigh)[5].meshindex;
	(*newneigh)[5].whichmesh = (*oldneigh)[5].whichmesh;
	(*newneigh)[6].meshindex = (*oldneigh)[6].meshindex;
	(*newneigh)[6].whichmesh = (*oldneigh)[6].whichmesh;
	(*newneigh)[7].meshindex = (*oldneigh)[7].meshindex;
	(*newneigh)[7].whichmesh = (*oldneigh)[7].whichmesh;

}
/********************************************************************************/
/* get_vneighborhoods() -- create neighborlist associated with vertices in		*/
/*	  initialized sub[subdivlevel].												*/
/*    If vertex has fewer than 8 neighbors, last elements in list will be == -1	*/
/*      and degree will be set to whatever the actual valence is.				*/
/*		NOTE:  count both edge and face vertices in valence						*/
/********************************************************************************/
void Subdivsurf::get_vneighborhoods(int subdivlevel)
{
	int nrows, ncols, nsrows, nscols;

    subdivgrid *submesh = &sub[subdivlevel];

	// the below are for the meshes, NOT the tiles.
    nrows = submesh->subnumrows;
    ncols = submesh->subnumcols;
    nsrows = submesh->sidenumrows;
    nscols = submesh->sidenumcols;

	int E = 2*nrows + 2*ncols - 4;   // edgelength of sidemesh (same as nsrows, I hope)
	                             //   ---offset for each edgerow
	if (E != nsrows) {
		fprintf(stderr, "problems in get_vneighborhoods()\n");
	    exit(0);
	}

	vneighborhoods[subdivlevel].initialized = true;
	vneighborhoods[subdivlevel].topneighbors = new Vertexneighbors[nrows*ncols];
	vneighborhoods[subdivlevel].bottomneighbors = new Vertexneighbors[nrows*ncols];
	vneighborhoods[subdivlevel].sideneighbors = new Vertexneighbors[nsrows*nscols];

	Vertexneighbors *topmesh = vneighborhoods[subdivlevel].topneighbors;
	Vertexneighbors *bottommesh = vneighborhoods[subdivlevel].bottomneighbors;
	Vertexneighbors *sidemesh = vneighborhoods[subdivlevel].sideneighbors;

	int col, row;
	// NOW:  fill in first top and bottom inner faces
	int dex;
	for (col = 1; col < ncols - 1; col++) {
		for (row = 1; row < nrows - 1; row++) {
			dex = col*nrows + row;

			load_vneighbor8(&topmesh[dex], TOP, TOP, TOP, TOP, TOP, TOP, TOP, TOP,
							dex + 1, dex + nrows + 1, dex + nrows, dex + nrows - 1,
							dex - 1, dex - nrows - 1, dex - nrows, dex - nrows + 1);

			load_vneighbor8(&bottommesh[dex], BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM, BOTTOM,
				BOTTOM, BOTTOM, dex + 1, dex - nrows + 1, dex - nrows, dex - nrows - 1,
				                dex - 1, dex + nrows - 1, dex + nrows, dex + nrows + 1);
		}
	}

	// NOW:  fill in side inner faces
	for (col = 1; col < nscols - 1; col++) {
		for (row = 1; row < nsrows - 1; row++) {
			dex = col*nsrows + row;

			load_vneighbor8(&sidemesh[dex], SIDE, SIDE, SIDE, SIDE, SIDE, SIDE, SIDE, SIDE,
				            dex + 1, dex - E + 1, dex - E, dex - E - 1,
							dex - 1, dex + E - 1, dex + E, dex + E + 1);
		}
	}

	// SPECIAL CASES
	// NOTE:  don't need to do top and bottom edge of side vertices, since they're the
	//   same as the edges of the top and bottom
	// NOTE:  can't use their information if we don't compute it---ah, no, can just
	//   copy from the top and bottom, so whole mesh is initialized
	// ---so, just two special cases on side, the row = 0 case and the row = E - 1 case
	// On top and bottom, 4 corners, and 4 edges special

	int ts_dex, bs_dex;

	// Fill in inner edge of top and bottom col==0
	col = 0;
	for (row = 1; row < nrows - 1; row++) {
		dex = col*nrows + row;

		// middle of 3 elements on edge bounding (col, row) == (0, row) on top and bottom
		ts_dex = row;
		bs_dex = ts_dex + (nscols - 1)*E;

		load_vneighbor8(&topmesh[dex], TOP, TOP, TOP, TOP, TOP, SIDE, SIDE, SIDE,
			            dex + 1, dex + nrows + 1, dex + nrows, dex + nrows - 1, dex - 1,
						ts_dex + E - 1, ts_dex + E, ts_dex + E + 1);


		load_vneighbor8(&bottommesh[dex], BOTTOM, SIDE, SIDE, SIDE, BOTTOM, BOTTOM, BOTTOM, BOTTOM,
			            dex + 1, bs_dex - E + 1, bs_dex - E, bs_dex - E - 1,
						dex - 1, dex + nrows - 1, dex + nrows, dex + nrows + 1);
	}

	// Fill in inner edge of top and bottom col==ncols - 1
	col = ncols - 1;
	for (row = 1; row < nrows - 1; row++) {
		dex = col*nrows + row;

		// middle of 3 elements on edge bounding (col, row) == (ncols - 1, row) on top and bottom
		ts_dex = 2*nrows + ncols - 3 - row;
		bs_dex = ts_dex + (nscols - 1)*E;

		load_vneighbor8(&topmesh[dex], TOP, TOP, TOP, TOP, TOP, SIDE, SIDE, SIDE,
			            dex - 1, dex - nrows - 1, dex - nrows, dex - nrows + 1, dex + 1,
						ts_dex + E - 1, ts_dex + E, ts_dex + E + 1);

		load_vneighbor8(&bottommesh[dex], BOTTOM, SIDE, SIDE, SIDE, BOTTOM, BOTTOM, BOTTOM, BOTTOM,
			            dex - 1, bs_dex - E + 1, bs_dex - E, bs_dex - E - 1,
						dex + 1, dex - nrows + 1, dex - nrows, dex - nrows - 1);
	}

	// Fill in inner edge of top and bottom row == 0
	// NOTE: special case for (row, col) = (0, 1) vertex on top and bottom,
	//   since have wrap-around of side vertices
	row = 0;
	for (col = 2; col < ncols - 1; col++) {
		dex = col*nrows + row;

		// middle of 3 elements on edge bounding (col, row) == (col, 0) on top and bottom
		ts_dex = E - col;
		bs_dex = ts_dex + (nscols - 1)*E;

		load_vneighbor8(&topmesh[dex], TOP, TOP, TOP, TOP, TOP, SIDE, SIDE, SIDE,
			            dex - nrows, dex - nrows + 1, dex + 1, dex + nrows + 1, dex + nrows,
						ts_dex + E - 1, ts_dex + E, ts_dex + E + 1);

		load_vneighbor8(&bottommesh[dex], BOTTOM, SIDE, SIDE, SIDE, BOTTOM, BOTTOM, BOTTOM, BOTTOM,
			            dex - nrows, bs_dex - E + 1, bs_dex - E, bs_dex - E - 1,
						dex + nrows, dex + nrows + 1, dex + 1, dex - nrows + 1);
	}

	// NOW:  do special case at wraparound edge
	// NOTE: special case for (row, col) = (0, 1) vertex on top and bottom,
	//   since have wrap-around of side vertices
	row = 0;
	col = 1;
	dex = col*nrows + row;

	// middle of 3 elements on edge bounding (col, row) == (col, 0) on top and bottom
	ts_dex = E - col;
	bs_dex = ts_dex + (nscols - 1)*E;

	//	topmesh[dex][7].meshindex = ts_dex + 1;	// special case, wrapped around
	load_vneighbor8(&topmesh[dex], TOP, TOP, TOP, TOP, TOP, SIDE, SIDE, SIDE,
			            dex - nrows, dex - nrows + 1, dex + 1, dex + nrows + 1, dex + nrows,
						ts_dex + E - 1, ts_dex + E, ts_dex + 1);

    //	bottommesh[dex][1].meshindex = bs_dex - 2*E + 1;	// special case, wrapped around
	load_vneighbor8(&bottommesh[dex], BOTTOM, SIDE, SIDE, SIDE, BOTTOM, BOTTOM, BOTTOM, BOTTOM,
			            dex - nrows, bs_dex - 2*E + 1, bs_dex - E, bs_dex - E - 1,
						dex + nrows, dex + nrows + 1, dex + 1, dex - nrows + 1);


	// NOW:  fill in inner edge of top and bottom row == nrows - 1
	row = nrows - 1;
	for (col = 1; col < ncols - 1; col++) {
		dex = col*nrows + row;

		// middle of 3 elements on edge bounding (col, row) == (col, nrows - 1) on top and bottom
		ts_dex = nrows + col - 1;
		bs_dex = ts_dex + (nscols - 1)*E;

		load_vneighbor8(&topmesh[dex], TOP, TOP, TOP, TOP, TOP, SIDE, SIDE, SIDE,
			            dex + nrows, dex + nrows - 1, dex - 1, dex - nrows - 1, dex - nrows,
						ts_dex + E - 1, ts_dex + E, ts_dex + E + 1);


		load_vneighbor8(&bottommesh[dex], BOTTOM, SIDE, SIDE, SIDE, BOTTOM, BOTTOM, BOTTOM, BOTTOM,
			            dex + nrows, bs_dex - E + 1, bs_dex - E, bs_dex - E - 1,
						dex - nrows, dex - nrows - 1, dex - 1, dex + nrows - 1);
	}

	// NOW:  fill in top and bottom corners

	// 3 edge elements adjacent on top and bottom 2nd row & 2nd from last
	int ts_dex1, ts_dex2, ts_dex3;
	int bs_dex1, bs_dex2, bs_dex3;

	// CORNER 1
	row = 0;
	col = 0;
	dex = col*nrows + row;

	// side indices are for counterclockwise (from top mesh) vertices
	//   in second row of sidegrid (first row == top mesh row)
	ts_dex1 = 2*E - 1;
	ts_dex2 = E;
	ts_dex3 = E + 1;

	bs_dex1 = ts_dex1 + (nscols - 3)*E;
	bs_dex2 = ts_dex2 + (nscols - 3)*E;
	bs_dex3 = ts_dex3 + (nscols - 3)*E;

	load_vneighbor6(&topmesh[dex], TOP, TOP, TOP, SIDE, SIDE, SIDE,
		            dex + 1, dex + nrows + 1, dex + nrows, ts_dex1, ts_dex2, ts_dex3);

	load_vneighbor6(&bottommesh[dex], BOTTOM, SIDE, SIDE, SIDE, BOTTOM, BOTTOM,
					dex + 1, bs_dex3, bs_dex2, bs_dex1, dex + nrows, dex + nrows + 1);

	// CORNER 2
	row = nrows - 1;
	col = 0;
	dex = col*nrows + row;

	ts_dex1 = E + nrows - 2;
	ts_dex2 = E + nrows - 1;
	ts_dex3 = E + nrows;

	bs_dex1 = ts_dex1 + (nscols - 3)*E;
	bs_dex2 = ts_dex2 + (nscols - 3)*E;
	bs_dex3 = ts_dex3 + (nscols - 3)*E;

	load_vneighbor6(&topmesh[dex], TOP, TOP, TOP, SIDE, SIDE, SIDE,
		            dex + nrows, dex + nrows - 1, dex - 1, ts_dex1, ts_dex2, ts_dex3);


	load_vneighbor6(&bottommesh[dex], BOTTOM, SIDE, SIDE, SIDE, BOTTOM, BOTTOM,
					dex + nrows, bs_dex3, bs_dex2, bs_dex1, dex - 1, dex + nrows - 1);

	// CORNER 3
	row = nrows - 1;
	col = ncols - 1;
	dex = col*nrows + row;

	ts_dex1 = E + nrows + ncols - 3;
	ts_dex2 = E + nrows + ncols - 2;
	ts_dex3 = E + nrows + ncols - 1;

	bs_dex1 = ts_dex1 + (nscols - 3)*E;
	bs_dex2 = ts_dex2 + (nscols - 3)*E;
	bs_dex3 = ts_dex3 + (nscols - 3)*E;

	load_vneighbor6(&topmesh[dex], TOP, TOP, TOP, SIDE, SIDE, SIDE,
		            dex - 1, dex - nrows - 1, dex - nrows, ts_dex1, ts_dex2, ts_dex3);

	load_vneighbor6(&bottommesh[dex], BOTTOM, SIDE, SIDE, SIDE, BOTTOM, BOTTOM,
					dex - 1, bs_dex3, bs_dex2, bs_dex1, dex - nrows, dex - nrows - 1);

	// CORNER 4  remember:   E = 2*nrows + 2*ncols - 4; 
	row = 0;
	col = ncols - 1;
	dex = col*nrows + row;

	ts_dex1 = E + 2*nrows + ncols - 4;
	ts_dex2 = E + 2*nrows + ncols - 3;
	ts_dex3 = E + 2*nrows + ncols - 2;
	if (2*nrows + ncols - 2 >= E)
		ts_dex3 -= E;   // wraparound occurs if ncols == 2

	bs_dex1 = ts_dex1 + (nscols - 3)*E;
	bs_dex2 = ts_dex2 + (nscols - 3)*E;
	bs_dex3 = ts_dex3 + (nscols - 3)*E;

	load_vneighbor6(&topmesh[dex], TOP, TOP, TOP, SIDE, SIDE, SIDE,
		            dex - nrows, dex - nrows + 1, dex + 1, ts_dex1, ts_dex2, ts_dex3);

	load_vneighbor6(&bottommesh[dex], BOTTOM, SIDE, SIDE, SIDE, BOTTOM, BOTTOM,
					dex - nrows, bs_dex3, bs_dex2, bs_dex1, dex + 1, dex - nrows + 1);


	// NOW:  fill in top and bottom edges and corners of sides
	col = 0;
	for (row = 0; row < nrows - 1; row++) {

		dex = col*nrows + row;	
		// side element on edge bounding (col, row) == (col, 0) on top and bottom
		ts_dex = row;
		bs_dex = ts_dex + (nscols - 1)*E;

		copy_vneighbor(&sidemesh[ts_dex], &topmesh[dex]);		
		copy_vneighbor(&sidemesh[bs_dex], &bottommesh[dex]);
	}

	row = nrows - 1;
	for (col = 0; col < ncols - 1; col++) {

		dex = col*nrows + row;
		ts_dex = nrows + col - 1;
		bs_dex = ts_dex + (nscols - 1)*E;

		copy_vneighbor(&sidemesh[ts_dex], &topmesh[dex]);		
		copy_vneighbor(&sidemesh[bs_dex], &bottommesh[dex]);
	}

	col = ncols - 1;
	for (row = 1; row < nrows; row++) {

		dex = col*nrows + row;
		ts_dex = 2*nrows + ncols - row - 3;
		bs_dex = ts_dex + (nscols - 1)*E;

		copy_vneighbor(&sidemesh[ts_dex], &topmesh[dex]);		
		copy_vneighbor(&sidemesh[bs_dex], &bottommesh[dex]);
	}

	row = 0;
	for (col = 1; col < ncols; col++) {

		dex = col*nrows + row;
		ts_dex = E - col;
		bs_dex = ts_dex + (nscols - 1)*E;

		copy_vneighbor(&sidemesh[ts_dex], &topmesh[dex]);		
		copy_vneighbor(&sidemesh[bs_dex], &bottommesh[dex]);
	}


	// NOW:  fill in side edge faces for siderow = 0 and siderow = nsrows
	row = 0;
	for (col = 1; col < nscols - 1; col++) {

		dex = col*nsrows + row;

		load_vneighbor8(&sidemesh[dex], SIDE, SIDE, SIDE, SIDE, SIDE, SIDE, SIDE, SIDE,
				            dex + 1, dex - E + 1, dex - E, dex - 1,
							dex + E - 1, dex + 2*E - 1, dex + E, dex + E + 1);

		// sidemesh[dex][3].meshindex = dex - 1;		// wrap around
		// sidemesh[dex][4].meshindex = dex + E - 1;	// wrap around
		// sidemesh[dex][5].meshindex = dex + 2*E - 1;	// wrap around
	}

	row = nsrows - 1;
	for (col = 1; col < nscols - 1; col++) {

		dex = col*nsrows + row;

		load_vneighbor8(&sidemesh[dex], SIDE, SIDE, SIDE, SIDE, SIDE, SIDE, SIDE, SIDE,
				            dex - E + 1, dex - 2*E + 1, dex - E, dex - E - 1,
							dex - 1, dex + E - 1, dex + E, dex + 1);

		// sidemesh[dex][0].meshindex = dex - E + 1;	// wrap around
		// sidemesh[dex][1].meshindex = dex - 2*E + 1;	// wrap around
		// sidemesh[dex][7].meshindex = dex + 1;		// wrap around
	}
}

/********************************************************************************/
/* create neighborlist associated with vertices produced by mod_subdiv()
/*    for current activesubmesh.  Contains a list of nverts Tileneighbors arrays,
/*    each giving index values associated with neighbors of indexing vertexnumber.
/*    Tileneighbors (int[8]) typedefed above.
/*    If fewer than 8 neighbors, last elements in list will be == -1.
/* Vertices are in counterclockwise order starting with an edge vertex
/*    (See def of class Tileneighbor above)
/* Returns false if no vertex-list exists at that subdivlevel.
/********************************************************************************/
bool Subdivsurf::get_vertexneighbors(int subdivlevel, int *nverts, Tileneighbors **neighborlist)
{
	int vcount;

	if (vneighborhoods[subdivlevel].initialized == false)
		return false;
	else {

		int numrows, numcols, numsiderows, numsidecols, lengthedge;

		subdivgrid *submesh = &sub[subdivlevel];

		numrows = submesh->subnumrows;
		numcols = submesh->subnumcols;
		numsiderows = submesh->sidenumrows;
		numsidecols = submesh->sidenumcols;
		lengthedge = submesh->edgelength;

		// number of points is top & bottom grids + sidegrid minus top and bottom edge,
		//   which were already listed in top & bottom grids
		int numpoints = 2*numrows*numcols + (numsiderows*numsidecols - 2*lengthedge);

		*nverts = numpoints;
		*neighborlist = new Tileneighbors[numpoints];

		Vertexneighbors *topmesh = vneighborhoods[subdivlevel].topneighbors;
		Vertexneighbors *bottommesh = vneighborhoods[subdivlevel].bottomneighbors;
		Vertexneighbors *sidemesh = vneighborhoods[subdivlevel].sideneighbors;

		Vertexneighbors *tempvert;
		int meshindex;

		int B = numrows*numcols;
		int E = 2*numrows + 2*numcols - 4;

		vcount = 0;
		int row, col;

		for (col = 0; col < numcols; col++) {
			for (row = 0; row < numrows; row++) {
				meshindex = col*numrows + row;
				tempvert = topmesh + meshindex;

				for (int neighcount = 0; neighcount < 8; neighcount++) {
					if (neighcount < tempvert->degree()) {

						if ((*tempvert)[neighcount].whichmesh == TOP)
							(*neighborlist)[vcount][neighcount] = (*tempvert)[neighcount].meshindex;
						else if ((*tempvert)[neighcount].whichmesh == BOTTOM)
							(*neighborlist)[vcount][neighcount] = (*tempvert)[neighcount].meshindex + B;
						else // side -- top siderow skipped
							(*neighborlist)[vcount][neighcount] = (*tempvert)[neighcount].meshindex + 2*B - E;
					}
					else
						(*neighborlist)[vcount][neighcount] = -1;

				}
				vcount++;
			}
		}

		for (col = 0; col < numcols; col++) {
			for (row = 0; row < numrows; row++) {
				meshindex = col*numrows + row;
				tempvert = bottommesh + meshindex;

				for (int neighcount = 0; neighcount < 8; neighcount++) {
					if (neighcount < tempvert->degree()) {

						if ((*tempvert)[neighcount].whichmesh == TOP)
							(*neighborlist)[vcount][neighcount] = (*tempvert)[neighcount].meshindex;
						else if ((*tempvert)[neighcount].whichmesh == BOTTOM)
							(*neighborlist)[vcount][neighcount] = (*tempvert)[neighcount].meshindex + B;
						else // side -- top siderow skipped
							(*neighborlist)[vcount][neighcount] = (*tempvert)[neighcount].meshindex + 2*B - E;
					}
					else
						(*neighborlist)[vcount][neighcount] = -1;

				}
				vcount++;
			}
		}

		// count from point (lengthedge) to (numsidepoints - lengthedge)
		int numsidepoints = numsiderows*numsidecols;
		int maxsidepoint = numsidepoints - lengthedge;

		for (int sideindex = lengthedge; sideindex < maxsidepoint; sideindex++) {

			tempvert = sidemesh + sideindex;

			for (int neighcount = 0; neighcount < 8; neighcount++) {
				if (neighcount < tempvert->degree()) {

					if ((*tempvert)[neighcount].whichmesh == TOP)
						(*neighborlist)[vcount][neighcount] = (*tempvert)[neighcount].meshindex;
					else if ((*tempvert)[neighcount].whichmesh == BOTTOM)
						(*neighborlist)[vcount][neighcount] = (*tempvert)[neighcount].meshindex + B;
					else {	// side
						int colnew, rownew;
						int neighborindex = (*tempvert)[neighcount].meshindex;

						if (neighborindex < lengthedge) {
							// need to convert from side-toprow to TOP location
							if (neighborindex < numrows) {
								colnew = 0;
								rownew = neighborindex;
							}
							else if (neighborindex < numrows + numcols - 1) {
								rownew = numrows - 1;
								colnew = neighborindex - (numrows - 1);
							}
							else if (neighborindex < 2*numrows + numcols - 2) {
								colnew = numcols - 1;
								rownew = (numrows - 1) - (neighborindex - (numrows + numcols - 2));
							}
							else { // sideindex < lengthedge
								colnew = (numcols - 1) - (neighborindex - (2*numrows + numcols - 3));
								rownew = 0;
							}
							(*neighborlist)[vcount][neighcount] = colnew*numrows + rownew;
						}
						else if (neighborindex >= maxsidepoint) {
							// need to convert from side-bottomrow to BOTTOM location
							neighborindex -= maxsidepoint;

							if (neighborindex < numrows) {
								colnew = 0;
								rownew = neighborindex;
							}
							else if (neighborindex < numrows + numcols - 1) {
								rownew = numrows - 1;
								colnew = neighborindex - (numrows - 1);
							}
							else if (neighborindex < 2*numrows + numcols - 2) {
								colnew = numcols - 1;
								rownew = (numrows - 1) - (neighborindex - (numrows + numcols - 2));
							}
							else { // sideindex < lengthedge
								colnew = (numcols - 1) - (neighborindex - (2*numrows + numcols - 3));
								rownew = 0;
							}
							(*neighborlist)[vcount][neighcount] = colnew*numrows + rownew + B;
						}
						else {
							// just subtract off length of not-include side-toprow
							(*neighborlist)[vcount][neighcount] = neighborindex + 2*B - E;
						}
					}
				}
				else
					(*neighborlist)[vcount][neighcount] = -1;

			}
			vcount++;
		}
	}
	if (vcount != *nverts) {
		fprintf(stderr, "Zounds!  'Swounds!  'Sblood! get %d when needed %d\n", vcount, *nverts);
		return false;
	}
	return true;
}

#define SQRT_17	4.123105625617660549821409855974	/* sqrt(17.0) */
//
// MASKS for limit surface and limit tangent vectors for even vertex
// --order here is [Vo, V1, V2, V3, V4, E1, E2, E3, E4]
//   where Vo is the center, V1..4 the neighbors across faces, and the E1..4 the neighbors
//   across edges.  Order is counterclockwise, and is V1-E1-V2-E2...etc.
// NOTE:
// reordered masks are in order E1-V2-E2-V3-E3-V4-E4-V1
//   as per multiplications in functions.  Need to clean this up.
double evenlimit8[9] = { 4.0/9, 1.0/36, 1.0/36, 1.0/36, 1.0/36, 1.0/9, 1.0/9, 1.0/9, 1.0/9 };

double eventangentA8[9] = {
   0.0,
  -1.0,
  -1.0,
   1.0,
   1.0,
  -4.0,
   0.0,
   4.0,
   0.0
};

double eventangentB8[9] = {
   0.0,
   1.0,
  -1.0,
  -1.0,
   1.0,
   0.0,
  -4.0,
   0.0,
   4.0
};

double evenlimit6[7] = { 3.0/8, 1.0/24, 1.0/24, 1.0/24, 1.0/6, 1.0/6, 1.0/6 };

double eventangentA6[7] = {
   0.0,
   2.0,
   2.0,
  -4.0,
   2.0 + 2.0*SQRT_17,
  -1.0 - SQRT_17,
  -1.0 - SQRT_17
};

double eventangentB6[7] = {
   0.0,
  -4.0,
   2.0,
   2.0,
   -1.0 - SQRT_17,
   2.0 + 2.0*SQRT_17,
   -1.0 - SQRT_17
};

double evenlimit8REORDER[9] = { 4.0/9, 1.0/9, 1.0/36, 1.0/9, 1.0/36, 1.0/9, 1.0/36, 1.0/9, 1.0/36 };

double eventangentA8REORDER[9] = {
   0.0,
  -4.0,
  -1.0,	   
   0.0,	   
   1.0,	   
   4.0,	   
   1.0,
   0.0,   
  -1.0
};

double eventangentB8REORDER[9] = {
   0.0,
   0.0,
  -1.0,
  -4.0,
  -1.0,
   0.0,
   1.0,
   4.0,
   1.0
};

double evenlimit6REORDER[7] = { 3.0/8, 1.0/6, 1.0/24, 1.0/6, 1.0/24, 1.0/6, 1.0/24 };

double eventangentA6REORDER[7] = {
   0.0,
   2.0 + 2.0*SQRT_17,
   2.0,
  -1.0 - SQRT_17,
  -4.0,
  -1.0 - SQRT_17,
   2.0
};

double eventangentB6REORDER[7] = {
   0.0,
   -1.0 - SQRT_17,
   2.0,
   2.0 + 2.0*SQRT_17,
   2.0,
   -1.0 - SQRT_17,
  -4.0
};

/********************************************************************************/
/* compute_limitpoint() -- uses Catmull-Clark rules to compute limit position	*/
/*    and normal for an even meshpoint in a 6 or 8 neighborhood.				*/
/********************************************************************************/
void Subdivsurf::compute_limitpoint(int dex, subdivgrid *submesh, Subneighborhood *nhoods,
									MeshID selectedmesh, subgridnode *thisgridnode)
{
	DbVector3 limitloc;
	DbVector3 limitnorm;

	DbVector3 limit_tangA, limit_tangB;

	subgridnode *thisnodelist;
	Vertexneighbors *nearverts;

	subgridnode nodelist[8];

	switch (selectedmesh) {
	case TOP:
		thisnodelist = submesh->topgrid;
		nearverts = &nhoods->topneighbors[dex];
		break;
	case BOTTOM:
		thisnodelist = submesh->bottomgrid;
		nearverts = &nhoods->bottomneighbors[dex];
		break;
	case SIDE:
		thisnodelist = submesh->sidegrid;
		nearverts = &nhoods->sideneighbors[dex];
		break;
	default:
		fprintf(stderr, "Hey, screwed in Subdivsurf::compute_limitpoint()!\n");
	}

	// Assign values that don't change for even vertices
	//   NOTE:  currently, uvt doesn't change for even vertices,
	//          to prevent coordinate creeping.  Should do so
	//          in a better way, though.
	thisgridnode->is_oddvert = false;
	thisgridnode->uvt.u = thisnodelist[dex].uvt.u;
	thisgridnode->uvt.v = thisnodelist[dex].uvt.v;
	thisgridnode->uvt.t = thisnodelist[dex].uvt.t;

	thisgridnode->nodenorm = thisnodelist[dex].nodenorm;
	thisgridnode->noderadius = thisnodelist[dex].noderadius;

	limit_tangA.set(0.0, 0.0, 0.0);
	limit_tangB.set(0.0, 0.0, 0.0);

	if (nearverts->degree() == 8) {

		limitloc = thisnodelist[dex].nodeloc*evenlimit8REORDER[0];

		// qiong working 12302002
		for (int meshdex = 0; meshdex < 8; meshdex++) {
			switch ((*nearverts)[meshdex].whichmesh) {
			case TOP:
				limitloc += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * evenlimit8REORDER[meshdex + 1];
				limit_tangA += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentA8REORDER[meshdex + 1];
				limit_tangB += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentB8REORDER[meshdex + 1];
				break;
			case BOTTOM: 
				limitloc += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * evenlimit8REORDER[meshdex + 1];
				limit_tangA += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentA8REORDER[meshdex + 1];
				limit_tangB += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentB8REORDER[meshdex + 1];
				break;
			case SIDE:
				limitloc += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * evenlimit8REORDER[meshdex + 1];
				limit_tangA += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentA8REORDER[meshdex + 1];
				limit_tangB += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentB8REORDER[meshdex + 1];
				break;
//			default: {
//						printf("Case error 1\n");
//					 }
				break;
			}
		}
	}
	else if (nearverts->degree() == 6) {

		limitloc = thisnodelist[dex].nodeloc*evenlimit6REORDER[0];

		for (int meshdex = 0; meshdex < 6; meshdex++) {
			switch ((*nearverts)[meshdex].whichmesh) {
			case TOP:
				limitloc += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * evenlimit6REORDER[meshdex + 1];
				limit_tangA += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentA6REORDER[meshdex + 1];
				limit_tangB += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentB6REORDER[meshdex + 1];
				break;
			case BOTTOM: 
				limitloc += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * evenlimit6REORDER[meshdex + 1];
				limit_tangA += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentA6REORDER[meshdex + 1];
				limit_tangB += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentB6REORDER[meshdex + 1];
				break;
			case SIDE:
				limitloc += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * evenlimit6REORDER[meshdex + 1];
				limit_tangA += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentA6REORDER[meshdex + 1];
				limit_tangB += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * eventangentB6REORDER[meshdex + 1];
				break;
//			default: {
//						printf("Case error 2\n");
//					 }
				break;
			}
		}
	}
	thisgridnode->nodeloc = limitloc;
	limitnorm = limit_tangA.cross(limit_tangB);
	limitnorm.selfnormalize();
	thisgridnode->nodenorm = limitnorm;

	int numrows = submesh->subnumrows;
	int numcols = submesh->subnumcols;
}

/********************************************************************************/
/* create_limit_mesh() -- uses Catmull-Clark rules to compute limit-mesh based  */
/*   on input subdivgrid.														*/
/********************************************************************************/
subdivgrid *Subdivsurf::create_limit_mesh(int subdivlevel)
{
    int nrows, ncols, nsrows, nscols;

    subdivgrid *submesh, *limitmesh;
	Subneighborhood *nearverts;

	submesh = &sub[subdivlevel];

	nearverts = &vneighborhoods[subdivlevel];

    nrows = submesh->subnumrows;
    ncols = submesh->subnumcols;
    nsrows = submesh->sidenumrows;
    nscols = submesh->sidenumcols;

	// Create the new limitmesh
	limitmesh = new subdivgrid;

	limitmesh->subnumrows = nrows;
	limitmesh->subnumcols = ncols;
	limitmesh->edgelength = submesh->edgelength;
	limitmesh->sidenumrows = nsrows;
	limitmesh->sidenumcols = nscols;
	limitmesh->topgrid = new subgridnode[nrows*ncols];
	limitmesh->bottomgrid = new subgridnode[nrows*ncols];
	limitmesh->sidegrid = new subgridnode[nsrows*nscols];

    int trow, tcol, meshdex;
    // Alright, now, let's do the split
    for (tcol = 0; tcol < ncols; tcol++) {
		for (trow = 0; trow < nrows; trow++) {
			meshdex = tcol*nrows + trow;
			compute_limitpoint(meshdex, submesh, nearverts, TOP, &limitmesh->topgrid[meshdex]);
		}
	}

	for (tcol = 0; tcol < ncols; tcol++) {
		for (trow = 0; trow < nrows; trow++) {
			meshdex = tcol*nrows + trow;
			compute_limitpoint(meshdex, submesh, nearverts, BOTTOM, &limitmesh->bottomgrid[meshdex]);
		}
	}

    for (tcol = 0; tcol < nscols; tcol++) {
        for (trow = 0; trow < nsrows; trow++) {
			meshdex = tcol*nsrows + trow;
			compute_limitpoint(meshdex, submesh, nearverts, SIDE, &limitmesh->sidegrid[meshdex]);
		}
    }

	// Set the involute locations and normals for vertices needing them
	int invol_dex;
	DbVector3 pval, pvalplusn;
	DbVector3 pvaltrue, pvalplusntrue;

//	glBegin(GL_LINES);
	for (invol_dex = 0; invol_dex < involuteset_top[subdivlevel].size(); invol_dex++) 
	{
		meshdex = involuteset_top[subdivlevel][invol_dex];
		limitmesh->topgrid[meshdex].true_nodeloc = submesh->topgrid[meshdex].true_nodeloc;
		limitmesh->topgrid[meshdex].true_nodenorm = submesh->topgrid[meshdex].true_nodenorm;


/*		if ((meshdex == 2 && subdivlevel == 0) || (meshdex == 6 && subdivlevel == 1)
			|| (meshdex == 20 && subdivlevel == 2) || (meshdex == 72 && subdivlevel == 3)) {
			pval = limitmesh->topgrid[meshdex].nodeloc;
			pvalplusn = pval + limitmesh->topgrid[meshdex].nodenorm;
			pvaltrue = submesh->topgrid[meshdex].true_nodeloc;
			pvalplusntrue = pvaltrue + submesh->topgrid[meshdex].true_nodenorm;
			glColor3d(0.0, 0.0, 1.0);
			glVertex3d(pval.x(), pval.y(), pval.z());
			glVertex3d(pvalplusn.x(), pvalplusn.y(), pvalplusn.z());
			glColor3d(1.0, 1.0, 0.0);
			glVertex3d(pvaltrue.x(), pvaltrue.y(), pvaltrue.z());
			glVertex3d(pvalplusntrue.x(), pvalplusntrue.y(), pvalplusntrue.z());
		}
 */
	}
    for (invol_dex = 0; invol_dex < involuteset_bottom[subdivlevel].size(); invol_dex++) 
	{
		meshdex = involuteset_bottom[subdivlevel][invol_dex];
		limitmesh->bottomgrid[meshdex].true_nodeloc = submesh->bottomgrid[meshdex].true_nodeloc;
		limitmesh->bottomgrid[meshdex].true_nodenorm = submesh->bottomgrid[meshdex].true_nodenorm;

/*		if (subdivlevel >= 2) {
			pval = limitmesh->bottomgrid[meshdex].nodeloc;
			pvalplusn = pval + limitmesh->bottomgrid[meshdex].nodenorm;
			pvaltrue = submesh->bottomgrid[meshdex].true_nodeloc;
			pvalplusntrue = pvaltrue + submesh->bottomgrid[meshdex].true_nodenorm;
			glColor3d(0.0, 0.0, 1.0);
			glVertex3d(pval.x(), pval.y(), pval.z());
			glVertex3d(pvalplusn.x(), pvalplusn.y(), pvalplusn.z());
			glColor3d(1.0, 1.0, 0.0);
			glVertex3d(pvaltrue.x(), pvaltrue.y(), pvaltrue.z());
			glVertex3d(pvalplusntrue.x(), pvalplusntrue.y(), pvalplusntrue.z());
		}
*/	}
	for (invol_dex = 0; invol_dex < involuteset_side[subdivlevel].size(); invol_dex++) 
	{
		meshdex = involuteset_side[subdivlevel][invol_dex];
		limitmesh->sidegrid[meshdex].true_nodeloc = submesh->sidegrid[meshdex].true_nodeloc;
		limitmesh->sidegrid[meshdex].true_nodenorm = submesh->sidegrid[meshdex].true_nodenorm;
/*
		pval = limitmesh->sidegrid[meshdex].nodeloc;
		pvalplusn = pval + limitmesh->sidegrid[meshdex].nodenorm;
		pvaltrue = submesh->sidegrid[meshdex].true_nodeloc;
		pvalplusntrue = pvaltrue + submesh->sidegrid[meshdex].true_nodenorm;
		glColor3d(0.0, 0.0, 1.0);
		glVertex3d(pval.x(), pval.y(), pval.z());
		glVertex3d(pvalplusn.x(), pvalplusn.y(), pvalplusn.z());
		glColor3d(1.0, 1.0, 0.0);
		glVertex3d(pvaltrue.x(), pvaltrue.y(), pvaltrue.z());
		glVertex3d(pvalplusntrue.x(), pvalplusntrue.y(), pvalplusntrue.z());
*/	}
	//glEnd();		// qiong 12302002 working what is this?
	return limitmesh;
}

/********************************************************************************/
/* inverse_limitmesh() -- send all even meshpoints to their Catmull-Clark		*/
/*   inverse positions---what point would produce this one in the limit if all	*/
/*	 others were unchanged.														*/
/********************************************************************************/
double inverselimit8REORDER[9] = { 9.0/4, -1.0/4, -1.0/16, -1.0/4, -1.0/16, -1.0/4, -1.0/16, -1.0/4, -1.0/16 };

double inverselimit6REORDER[7] = { 8.0/3, -4.0/9, -1.0/9, -4.0/9, -1.0/9, -4.0/9, -1.0/9 };

/********************************************************************************/
/* compute_inverselimitpoint() -- uses Catmull-Clark rules to compute inverse	*/
/*    limit position for an even meshpoint in a 6 or 8 neighborhood.			*/
/********************************************************************************/
void Subdivsurf::compute_inverselimitpoint(int dex, subdivgrid *submesh, Subneighborhood *nhoods,
									       MeshID selectedmesh, subgridnode *thisgridnode)
{
	DbVector3 limitloc;

	subgridnode *thisnodelist;
	Vertexneighbors *nearverts;

	subgridnode nodelist[8];

	switch (selectedmesh) {
	case TOP:
		thisnodelist = submesh->topgrid;
		nearverts = &nhoods->topneighbors[dex];
		break;
	case BOTTOM:
		thisnodelist = submesh->bottomgrid;
		nearverts = &nhoods->bottomneighbors[dex];
		break;
	case SIDE:
		thisnodelist = submesh->sidegrid;
		nearverts = &nhoods->sideneighbors[dex];
		break;
	default:
		fprintf(stderr, "Hey, screwed in Subdivsurf::compute_inverselimitpoint()!\n");
	}

	// Assign values that don't change for even vertices
	//   NOTE:  currently, uvt doesn't change for even vertices,
	//          to prevent coordinate creeping.  Should do so
	//          in a better way, though.
	thisgridnode->is_oddvert = false;
	thisgridnode->uvt.u = thisnodelist[dex].uvt.u;
	thisgridnode->uvt.v = thisnodelist[dex].uvt.v;
	thisgridnode->uvt.t = thisnodelist[dex].uvt.t;
	thisgridnode->nodenorm = thisnodelist[dex].nodenorm;
	thisgridnode->noderadius = thisnodelist[dex].noderadius;

	if (nearverts->degree() == 8) {

		limitloc = thisnodelist[dex].nodeloc*inverselimit8REORDER[0];

		for (int meshdex = 0; meshdex < 8; meshdex++) {
			switch ((*nearverts)[meshdex].whichmesh) {
			case TOP:
				limitloc += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit8REORDER[meshdex + 1];
				break;
			case BOTTOM: 
				limitloc += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit8REORDER[meshdex + 1];
				break;
			case SIDE:
				limitloc += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit8REORDER[meshdex + 1];
				break;
			}
		}
	}
	else if (nearverts->degree() == 6) {

		limitloc = thisnodelist[dex].nodeloc*inverselimit6REORDER[0];

		for (int meshdex = 0; meshdex < 6; meshdex++) {
			switch ((*nearverts)[meshdex].whichmesh) {
			case TOP:
				limitloc += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit6REORDER[meshdex + 1];
				break;
			case BOTTOM: 
				limitloc += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit6REORDER[meshdex + 1];
				break;
			case SIDE:
				limitloc += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit6REORDER[meshdex + 1];
				break;
			}
		}
	}

	DbVector3 midloc = thisnodelist[dex].nodeloc + (limitloc - thisnodelist[dex].nodeloc)*0.5;

	thisgridnode->nodeloc = midloc;
}

/********************************************************************************/
/* compute_inverselimitpointLEVEL2() -- uses Catmull-Clark rules to compute inverse	*/
/*    limit position for an even meshpoint in a 6 or 8 neighborhood.  This uses */
/*    an input subgridnode from the original mesh for the limit point, but		*/
/*    neighbors from the previously computed inverse-limitpoint mesh, for a		*/
/*    second interation.														*/
/********************************************************************************/
void Subdivsurf::compute_inverselimitpointLEVEL2(int dex, subgridnode *oldnode, subdivgrid *submesh,
												 Subneighborhood *nhoods,
									             MeshID selectedmesh, subgridnode *thisgridnode)
{
	DbVector3 limitloc;

	subgridnode *thisnodelist;
	Vertexneighbors *nearverts;

	subgridnode nodelist[8];

	switch (selectedmesh) {
	case TOP:
		thisnodelist = submesh->topgrid;
		nearverts = &nhoods->topneighbors[dex];
		break;
	case BOTTOM:
		thisnodelist = submesh->bottomgrid;
		nearverts = &nhoods->bottomneighbors[dex];
		break;
	case SIDE:
		thisnodelist = submesh->sidegrid;
		nearverts = &nhoods->sideneighbors[dex];
		break;
	default:
		fprintf(stderr, "Hey, screwed in Subdivsurf::compute_limitpoint()!\n");
	}

	// Assign values that don't change for even vertices
	//   NOTE:  currently, uvt doesn't change for even vertices,
	//          to prevent coordinate creeping.  Should do so
	//          in a better way, though.
	thisgridnode->is_oddvert = false;
	thisgridnode->uvt.u = oldnode->uvt.u;
	thisgridnode->uvt.v = oldnode->uvt.v;
	thisgridnode->uvt.t = oldnode->uvt.t;
	thisgridnode->nodenorm = oldnode->nodenorm;
	thisgridnode->noderadius = oldnode->noderadius;

	if (nearverts->degree() == 8) {

		limitloc = oldnode->nodeloc*inverselimit8REORDER[0];

		for (int meshdex = 0; meshdex < 8; meshdex++) {
			switch ((*nearverts)[meshdex].whichmesh) {
			case TOP:
				limitloc += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit8REORDER[meshdex + 1];
				break;
			case BOTTOM: 
				limitloc += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit8REORDER[meshdex + 1];
				break;
			case SIDE:
				limitloc += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit8REORDER[meshdex + 1];
				break;
			}
		}
	}
	else if (nearverts->degree() == 6) {

		limitloc = oldnode->nodeloc*inverselimit6REORDER[0];

		for (int meshdex = 0; meshdex < 6; meshdex++) {
			switch ((*nearverts)[meshdex].whichmesh) {
			case TOP:
				limitloc += submesh->topgrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit6REORDER[meshdex + 1];
				break;
			case BOTTOM: 
				limitloc += submesh->bottomgrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit6REORDER[meshdex + 1];
				break;
			case SIDE:
				limitloc += submesh->sidegrid[(*nearverts)[meshdex].meshindex].nodeloc * inverselimit6REORDER[meshdex + 1];
				break;
			}
		}
	}

	DbVector3 midloc = thisnodelist[dex].nodeloc + (limitloc - thisnodelist[dex].nodeloc)*0.5;
	thisgridnode->nodeloc = midloc;
}

/********************************************************************************/
/* inverse_limit_mesh() -- uses Catmull-Clark rules to compute inverse mesh		*/
/*    producing original positions as limit points.  Does local inverse average */
/*    only, gets perturbed mesh, and then can compute new subdivision mesh, to	*/
/*    see if perturbed mesh gave better results.  DOUBTFUL.						*/
/********************************************************************************/
subdivgrid *Subdivsurf::inverse_limit_mesh(int subdivlevel)
{
    int nrows, ncols, nsrows, nscols;

    subdivgrid *submesh, *invlimmesh;
	Subneighborhood *nearverts;

	submesh = &sub[subdivlevel];

	nearverts = &vneighborhoods[subdivlevel];

    nrows = submesh->subnumrows;
    ncols = submesh->subnumcols;
    nsrows = submesh->sidenumrows;
    nscols = submesh->sidenumcols;

	// Create the new limitmesh
	invlimmesh = new subdivgrid;

	invlimmesh->subnumrows = nrows;
	invlimmesh->subnumcols = ncols;
	invlimmesh->edgelength = submesh->edgelength;
	invlimmesh->sidenumrows = nsrows;
	invlimmesh->sidenumcols = nscols;
	invlimmesh->topgrid = new subgridnode[nrows*ncols];
	invlimmesh->bottomgrid = new subgridnode[nrows*ncols];
	invlimmesh->sidegrid = new subgridnode[nsrows*nscols];

    int trow, tcol, meshdex;
    // Alright, now, let's do the split
    for (tcol = 0; tcol < ncols; tcol++) {
		for (trow = 0; trow < nrows; trow++) {
			meshdex = tcol*nrows + trow;

			compute_inverselimitpoint(meshdex, submesh, nearverts, TOP, &invlimmesh->topgrid[meshdex]);
		}
	}

	for (tcol = 0; tcol < ncols; tcol++) {
		for (trow = 0; trow < nrows; trow++) {
			meshdex = tcol*nrows + trow;

			compute_inverselimitpoint(meshdex, submesh, nearverts, BOTTOM, &invlimmesh->bottomgrid[meshdex]);
		}
	}

    for (tcol = 0; tcol < nscols; tcol++) {
        for (trow = 0; trow < nsrows; trow++) {
			meshdex = tcol*nsrows + trow;

			compute_inverselimitpoint(meshdex, submesh, nearverts, SIDE, &invlimmesh->sidegrid[meshdex]);
		}
    }

	subdivgrid *oldmesh;
	for (int testnum = 0; testnum < SOR_ITERATION_COUNT; testnum++) {

		// Create the new level 2 limitmesh
		oldmesh = invlimmesh;
		invlimmesh = new subdivgrid;

		invlimmesh->subnumrows = nrows;
		invlimmesh->subnumcols = ncols;
		invlimmesh->edgelength = submesh->edgelength;
		invlimmesh->sidenumrows = nsrows;
		invlimmesh->sidenumcols = nscols;
		invlimmesh->topgrid = new subgridnode[nrows*ncols];
		invlimmesh->bottomgrid = new subgridnode[nrows*ncols];
		invlimmesh->sidegrid = new subgridnode[nsrows*nscols];

		// Alright, now, let's do the split
		for (tcol = 0; tcol < ncols; tcol++) {
			for (trow = 0; trow < nrows; trow++) {
				meshdex = tcol*nrows + trow;

				compute_inverselimitpointLEVEL2(meshdex, &submesh->topgrid[meshdex], oldmesh,
					nearverts, TOP, &invlimmesh->topgrid[meshdex]);
			}
		}

		for (tcol = 0; tcol < ncols; tcol++) {
			for (trow = 0; trow < nrows; trow++) {
				meshdex = tcol*nrows + trow;

				compute_inverselimitpointLEVEL2(meshdex, &submesh->bottomgrid[meshdex], oldmesh, 
					nearverts, BOTTOM, &invlimmesh->bottomgrid[meshdex]);
			}
		}

		for (tcol = 0; tcol < nscols; tcol++) {
			for (trow = 0; trow < nsrows; trow++) {
				meshdex = tcol*nsrows + trow;

				compute_inverselimitpointLEVEL2(meshdex, &submesh->sidegrid[meshdex], oldmesh,
					nearverts, SIDE, &invlimmesh->sidegrid[meshdex]);
			}
		}

		delete []oldmesh->topgrid;
		delete []oldmesh->bottomgrid;
		delete []oldmesh->sidegrid;
		delete oldmesh;
	}
	// qiong 12302002 now the original mesh has been inverselly calculated
	// Set the involute locations and normals for vertices needing them
	int invol_dex;
	for (invol_dex = 0; invol_dex < involuteset_top[subdivlevel].size(); invol_dex++) {
		meshdex = involuteset_top[subdivlevel][invol_dex];
		invlimmesh->topgrid[meshdex].true_nodeloc = submesh->topgrid[meshdex].true_nodeloc;
		invlimmesh->topgrid[meshdex].true_nodenorm = submesh->topgrid[meshdex].true_nodenorm;
	}
    for (invol_dex = 0; invol_dex < involuteset_bottom[subdivlevel].size(); invol_dex++) {
		meshdex = involuteset_bottom[subdivlevel][invol_dex];
		invlimmesh->bottomgrid[meshdex].true_nodeloc = submesh->bottomgrid[meshdex].true_nodeloc;
		invlimmesh->bottomgrid[meshdex].true_nodenorm = submesh->bottomgrid[meshdex].true_nodenorm;
	}
	for (invol_dex = 0; invol_dex < involuteset_side[subdivlevel].size(); invol_dex++) {
		meshdex = involuteset_side[subdivlevel][invol_dex];
		invlimmesh->sidegrid[meshdex].true_nodeloc = submesh->sidegrid[meshdex].true_nodeloc;
		invlimmesh->sidegrid[meshdex].true_nodenorm = submesh->sidegrid[meshdex].true_nodenorm;
	}

	return invlimmesh;
}

inline double AngleBetweenVectors(DbVector3 v1, DbVector3 v2)
{
	double dotP = v1.dot(v2);
	double c = acos(dotP);
#ifdef _MSC_VER
	if (_isnan(c)) {
		// For an unknown reason, this actually happens on Intel-based PC's running MS Visual Studio
		//printf("Error: Subdivsurf.cpp/AngleBetweenVectors, v1.dot(v2) is out of range [-1, 1]!\n");
		if(dotP > 1)
			return 0;
		else
			return M_PI;
	}
	else
#endif
		return c;
}

/****************************************************************************************/
/* create_normalinterpolating_mesh() -- for a level-2 mesh, compute a new mesh that		*/
/*		interpolates .true_nodenorm values at involute points stored in involutesets.	*/
/*		At level two, all 1-neighborhoods are disjoint.									*/
/* It is an error to call this function if the level-2 mesh has not already been		*/
/*		computed.																		*/
/* MODIFICATION: this is now done in-place on sub[2] submesh, so no copying is			*/
/*		necessary.  Reducing time from O(Vertices) to O(involutes) = O(1).				*/
/****************************************************************************************/
void Subdivsurf::create_normalinterpolating_mesh()
{
    int nrows, ncols, nsrows, nscols;
    int i;

    subdivgrid *submesh;
	Subneighborhood *nearverts;

	submesh = &sub[2];

	nearverts = &vneighborhoods[2];

    nrows = submesh->subnumrows;
    ncols = submesh->subnumcols;
    nsrows = submesh->sidenumrows;
    nscols = submesh->sidenumcols;

	// For involute vertices
	//    (1) find their limit positions and limit normals
	//    (2) compute a rotation about the limit position (as a quaternion)
	//           bringing it to location of true_nodenorm
	//    (3) rotate the involute vertex about the true_nodenorm by given rotation
	//    (4) rotate all neighbors of the involute vertex by this same amount
	int invol_dex;
    int trow, tcol, meshdex;
	DbVector3 pval, pvalplusn;
	DbVector3 true_pos, true_norm;
	DbVector3 limit_pos, limit_norm;
	double theta;
	DbVector3 rotaxis;
	DbVector3 posvec;
	Quat rot_true2limitnorm;
	subgridnode limitnode;

		// Save current color
	glPushAttrib(GL_CURRENT_BIT);

	Vector3D posvecTmp;

	/****************************************************************************************/
	/* compute perturbation for topgrid vertices
	/****************************************************************************************/
	for (invol_dex = 0; invol_dex < involuteset_top[2].size(); invol_dex++) {
		meshdex = involuteset_top[2][invol_dex];

		compute_limitpoint(meshdex, submesh, nearverts, TOP, &limitnode);

		limit_pos = limitnode.nodeloc;
		limit_norm = limitnode.nodenorm;
		true_norm = submesh->topgrid[meshdex].true_nodenorm;
		limit_norm.selfnormalize();
		true_norm.selfnormalize();

		// qiong working 01032002
		//theta = acos(limit_norm.dot(true_norm));
		theta=AngleBetweenVectors(limit_norm, true_norm);

		// if theta is small, ignore this vertex
		if (theta > THETA_TOL) {

			double rottheta = theta - THETA_TOL;

			Vertexneighbors *nearvert = &nearverts->topneighbors[meshdex];
			// Draw initial neighborhood if DRAWNORMINTERP set
			if (DRAWNORMINTERP) {
				glColor3d(0.0, 1.0, 0.0);
				glBegin(GL_POINTS);
				submesh->topgrid[meshdex].nodeloc.glVertex();
				glEnd();
				glBegin(GL_LINE_LOOP);
				for (i = 0; i < nearvert->degree(); i++) {

					switch ((*nearvert)[i].whichmesh) {
					case TOP:
						submesh->topgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case BOTTOM:
						submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case SIDE:
						submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					}
				}
				glEnd();
			}

			rotaxis = limit_norm.cross(true_norm);

			//rot_true2limitnorm.rot(rotaxis, rottheta);
			rot_true2limitnorm.setAxisAngle(Vector3D(rotaxis.X(), rotaxis.Y(), rotaxis.Z()), rottheta);

			posvec = submesh->topgrid[meshdex].nodeloc - limit_pos;

			//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z()); 
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

			submesh->topgrid[meshdex].nodeloc = posvec + limit_pos;

			for (i = 0; i < nearvert->degree(); i++) {

				switch ((*nearvert)[i].whichmesh) {
				case TOP:			
					posvec = submesh->topgrid[(*nearvert)[i].meshindex].nodeloc - limit_pos;

					//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z());
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

					submesh->topgrid[(*nearvert)[i].meshindex].nodeloc = posvec + limit_pos;
					break;

				case BOTTOM:

					posvec = submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc - limit_pos;

					//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z());
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

					submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc = posvec + limit_pos;
					break;
				case SIDE:
					posvec = submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc - limit_pos;

					//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z());
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

					submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc = posvec + limit_pos;
					break;
				}
			}

			// Draw perturbed neighborhood if DRAWNORMINTERP set
			if (DRAWNORMINTERP) {
				glColor3d(1.0, 0.0, 1.0);
				glBegin(GL_POINTS);
				submesh->topgrid[meshdex].nodeloc.glVertex();
				glEnd();
				glBegin(GL_LINE_LOOP);
				for (i = 0; i < nearvert->degree(); i++) {

					switch ((*nearvert)[i].whichmesh) {
					case TOP:
						submesh->topgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case BOTTOM:
						submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case SIDE:
						submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					}
				}
				glEnd();
			}
		}
	}

	/****************************************************************************************/
	/* compute perturbation for bottomgrid vertices
	/****************************************************************************************/
    for (invol_dex = 0; invol_dex < involuteset_bottom[2].size(); invol_dex++) {
		meshdex = involuteset_bottom[2][invol_dex];

		compute_limitpoint(meshdex, submesh, nearverts, BOTTOM, &limitnode);

		limit_pos = limitnode.nodeloc;
		limit_norm = limitnode.nodenorm;
		true_norm = submesh->bottomgrid[meshdex].true_nodenorm;
		limit_norm.selfnormalize();
		true_norm.selfnormalize();

		// qiong working 01032002
		//theta = acos(limit_norm.dot(true_norm));
		theta=AngleBetweenVectors(limit_norm, true_norm);

		// if theta is small, ignore this vertex
		if (theta > THETA_TOL) {

			double rottheta = theta - THETA_TOL;

			Vertexneighbors *nearvert = &nearverts->bottomneighbors[meshdex];
			// Draw initial neighborhood if DRAWNORMINTERP set
			if (DRAWNORMINTERP) {
				glColor3d(0.0, 1.0, 0.0);
				glBegin(GL_POINTS);
				submesh->bottomgrid[meshdex].nodeloc.glVertex();
				glEnd();
				glBegin(GL_LINE_LOOP);
				for (i = 0; i < nearvert->degree(); i++) {

					switch ((*nearvert)[i].whichmesh) {
					case TOP:
						submesh->topgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case BOTTOM:
						submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case SIDE:
						submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					}
				}
				glEnd();
			}

			rotaxis = limit_norm.cross(true_norm);

			//rot_true2limitnorm.rot(rotaxis, rottheta);
			rot_true2limitnorm.setAxisAngle(Vector3D(rotaxis.X(), rotaxis.Y(), rotaxis.Z()), rottheta);

			posvec = submesh->bottomgrid[meshdex].nodeloc - limit_pos;

			//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z()); 
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

			submesh->bottomgrid[meshdex].nodeloc = posvec + limit_pos;

			for (i = 0; i < nearvert->degree(); i++) {

				switch ((*nearvert)[i].whichmesh) {
				case TOP:			
					posvec = submesh->topgrid[(*nearvert)[i].meshindex].nodeloc - limit_pos;

					//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z()); 
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

					submesh->topgrid[(*nearvert)[i].meshindex].nodeloc = posvec + limit_pos;
					break;
				case BOTTOM:
					posvec = submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc - limit_pos;

					//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z()); 
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

					submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc = posvec + limit_pos;
					break;
				case SIDE:
					posvec = submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc - limit_pos;

					//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z()); 
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

					submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc = posvec + limit_pos;
					break;
				}
			}

			// Draw perturbed neighborhood if DRAWNORMINTERP set
			if (DRAWNORMINTERP) {
				glColor3d(1.0, 0.0, 1.0);
				glBegin(GL_POINTS);
				submesh->bottomgrid[meshdex].nodeloc.glVertex();
				glEnd();
				glBegin(GL_LINE_LOOP);
				for (i = 0; i < nearvert->degree(); i++) {

					switch ((*nearvert)[i].whichmesh) {
					case TOP:
						submesh->topgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case BOTTOM:
						submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case SIDE:
						submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					}
				}
				glEnd();
			}
 		}
	}

	/****************************************************************************************/
	/* compute perturbation for sidegrid vertices
	/****************************************************************************************/
	for (invol_dex = 0; invol_dex < involuteset_side[2].size(); invol_dex++) {
		meshdex = involuteset_side[2][invol_dex];

		// IGNORE any meshindex on top or bottom row, since this was already done
		//   at edge of top and bottom grids.  At end, copy edge values into sides
		if ((meshdex < nsrows) || (meshdex >= (nscols - 1)*nsrows))
			continue;

		compute_limitpoint(meshdex, submesh, nearverts, SIDE, &limitnode);

		limit_pos = limitnode.nodeloc;
		limit_norm = limitnode.nodenorm;
		true_norm = submesh->sidegrid[meshdex].true_nodenorm;
		limit_norm.selfnormalize();
		true_norm.selfnormalize();

		// qiong working 01032002
		//theta = acos(limit_norm.dot(true_norm));
		theta=AngleBetweenVectors(limit_norm, true_norm);

		// if theta is small, ignore this vertex
		if (theta > THETA_TOL) {

			double rottheta = theta - THETA_TOL;

			Vertexneighbors *nearvert = &nearverts->sideneighbors[meshdex];
			// Draw initial neighborhood if DRAWNORMINTERP set
			if (DRAWNORMINTERP) {
				glColor3d(0.0, 1.0, 0.0);
				glBegin(GL_POINTS);
				submesh->sidegrid[meshdex].nodeloc.glVertex();
				glEnd();
				glBegin(GL_LINE_LOOP);
				for (i = 0; i < nearvert->degree(); i++) {

					switch ((*nearvert)[i].whichmesh) {
					case TOP:
						submesh->topgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case BOTTOM:
						submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case SIDE:
						submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					}
				}
				glEnd();
			}

			rotaxis = limit_norm.cross(true_norm);

			//rot_true2limitnorm.rot(rotaxis, rottheta);
			rot_true2limitnorm.setAxisAngle(Vector3D(rotaxis.X(), rotaxis.Y(), rotaxis.Z()), rottheta);

			posvec = submesh->sidegrid[meshdex].nodeloc - limit_pos;

			//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z()); 
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

			submesh->sidegrid[meshdex].nodeloc = posvec + limit_pos;

			for (i = 0; i < nearvert->degree(); i++) {

				switch ((*nearvert)[i].whichmesh) {
				case TOP:			
					posvec = submesh->topgrid[(*nearvert)[i].meshindex].nodeloc - limit_pos;

					//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z()); 
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

					submesh->topgrid[(*nearvert)[i].meshindex].nodeloc = posvec + limit_pos;
					break;
				case BOTTOM:
					posvec = submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc - limit_pos;

					//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z()); 
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

					submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc = posvec + limit_pos;
					break;
				case SIDE:
					posvec = submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc - limit_pos;

					//rot_true2limitnorm.rotate_vec(posvec);
			posvecTmp.set(posvec.X(), posvec.Y(), posvec.Z()); 
			rot_true2limitnorm.rotateVector(posvecTmp);
			posvec.set(posvecTmp.getX(), posvecTmp.getY(), posvecTmp.getZ());

					submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc = posvec + limit_pos;
					break;
				}
			}

			// Draw perturbed neighborhood if DRAWNORMINTERP set
			if (DRAWNORMINTERP) {
				glColor3d(1.0, 0.0, 1.0);
				glBegin(GL_POINTS);
				submesh->sidegrid[meshdex].nodeloc.glVertex();
				glEnd();
				glBegin(GL_LINE_LOOP);
				for (i = 0; i < nearvert->degree(); i++) {

					switch ((*nearvert)[i].whichmesh) {
					case TOP:
						submesh->topgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case BOTTOM:
						submesh->bottomgrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					case SIDE:
						submesh->sidegrid[(*nearvert)[i].meshindex].nodeloc.glVertex();
						break;
					}
				}
				glEnd();
			}
		}
	}

	// Save current color
	glPopAttrib();

	/****************************************************************************************/
	/* May have to copy from the top and bottom edges to the side-top and side-bottom,
	/*     respectively.  YES, we do.  Didn't perturb edge involute atoms on sides, and top
	/*     and bottom grid perturbations didn't write to first or last edge columns (top and
	/*     bottom edges.
	/****************************************************************************************/
	// NOW:  copy the top and bottom edges to the edgemesh
    int sdex_top = 0;       // index for sidelist
    int sdex_bottom = (nscols - 1)*nsrows;   // top and bottom
	tcol = 0;
    for (trow = 0; trow < nrows; trow++) {
        meshdex = tcol*nrows + trow;

		submesh->sidegrid[sdex_top] = submesh->topgrid[meshdex];
		submesh->sidegrid[sdex_bottom] = submesh->bottomgrid[meshdex];
		sdex_top++;
		sdex_bottom++;
    }
    trow = nrows - 1;
    for (tcol = 1; tcol < ncols; tcol++) {
        meshdex = tcol*nrows + trow;

		submesh->sidegrid[sdex_top] = submesh->topgrid[meshdex];
		submesh->sidegrid[sdex_bottom] = submesh->bottomgrid[meshdex];
		sdex_top++;
		sdex_bottom++;
    }
    tcol = ncols - 1;
    for (trow = nrows - 2; trow >= 0; trow--) {
        meshdex = tcol*nrows + trow;

		submesh->sidegrid[sdex_top] = submesh->topgrid[meshdex];
		submesh->sidegrid[sdex_bottom] = submesh->bottomgrid[meshdex];
		sdex_top++;
		sdex_bottom++;
    }
    trow = 0;
    for (tcol = ncols - 2; tcol > 0; tcol--) {
        meshdex = tcol*nrows + trow;

		submesh->sidegrid[sdex_top] = submesh->topgrid[meshdex];
		submesh->sidegrid[sdex_bottom] = submesh->bottomgrid[meshdex];
		sdex_top++;
		sdex_bottom++;
    }
}

